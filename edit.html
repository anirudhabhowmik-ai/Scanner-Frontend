<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Edit PDF Online Free | PDFMaster</title>
    <meta
      name="description"
      content="Edit PDF online: add text, images, shapes, draw, and annotate PDFs for free."
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Inter:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- CSS -->
    <link rel="stylesheet" href="./css/style.css" />
    <link rel="stylesheet" href="./css/edit.css" />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="./images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="./images/favicon-16x16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="./images/apple-touch-icon.png"
    />

    <!-- Google AdSense (Replace with your AdSense ID) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5797619165090350"
      crossorigin="anonymous"
    ></script>

    <style>
      /* Toast Notification Styles */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        max-width: 350px;
      }

      .toast {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 16px 20px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideIn 0.3s ease-out;
        border-left: 4px solid #4f46e5;
      }

      .toast.success {
        border-left-color: #10b981;
      }

      .toast.error {
        border-left-color: #ef4444;
      }

      .toast.info {
        border-left-color: #3b82f6;
      }

      .toast.warning {
        border-left-color: #f59e0b;
      }

      .toast-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .toast.success .toast-icon {
        color: #10b981;
      }

      .toast.error .toast-icon {
        color: #ef4444;
      }

      .toast.info .toast-icon {
        color: #3b82f6;
      }

      .toast.warning .toast-icon {
        color: #f59e0b;
      }

      .toast-content {
        flex: 1;
      }

      .toast-title {
        font-weight: 600;
        margin-bottom: 4px;
        color: #1f2937;
      }

      .toast-message {
        font-size: 14px;
        color: #6b7280;
      }

      .toast-close {
        background: none;
        border: none;
        color: #9ca3af;
        cursor: pointer;
        font-size: 18px;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toast-close:hover {
        color: #4b5563;
      }

      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }

      .toast.hiding {
        animation: slideOut 0.3s ease-out forwards;
      }

      /* Custom Modal Styles */
      .custom-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .custom-modal-overlay.show {
        opacity: 1;
      }

      .custom-modal {
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        max-width: 450px;
        width: 90%;
        transform: scale(0.9);
        transition: transform 0.3s ease;
      }

      .custom-modal-overlay.show .custom-modal {
        transform: scale(1);
      }

      .custom-modal-header {
        padding: 24px 24px 16px;
        border-bottom: 1px solid #e5e7eb;
      }

      .custom-modal-title {
        font-size: 20px;
        font-weight: 600;
        color: #1f2937;
        margin: 0;
      }

      .custom-modal-body {
        padding: 24px;
        color: #4b5563;
        font-size: 15px;
        line-height: 1.6;
      }

      .custom-modal-footer {
        padding: 16px 24px 24px;
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .custom-modal-btn {
        padding: 10px 20px;
        border-radius: 6px;
        border: none;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
      }

      .custom-modal-btn-primary {
        background: #4f46e5;
        color: white;
      }

      .custom-modal-btn-primary:hover {
        background: #4338ca;
      }

      .custom-modal-btn-danger {
        background: #ef4444;
        color: white;
      }

      .custom-modal-btn-danger:hover {
        background: #dc2626;
      }

      .custom-modal-btn-secondary {
        background: #f3f4f6;
        color: #4b5563;
      }

      .custom-modal-btn-secondary:hover {
        background: #e5e7eb;
      }
    </style>
  </head>

  <body>
    <section id="header-placeholder"></section>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <section class="merge-tool">
      <div class="container">
        <h1>Edit PDF</h1>
        <p>Add text, images, shapes, and annotations to your PDF.</p>

        <div class="upload-section" id="uploadSection">
          <label for="pdfUpload" class="upload-label">
            <i class="fa fa-upload"></i> Choose PDF file
          </label>
          <input type="file" id="pdfUpload" accept=".pdf" class="hidden" />

          <div id="uploadLoader" class="upload-loader" style="display: none">
            <div class="spinner"></div>
            <p>Loading PDF…</p>
          </div>
        </div>

        <div id="editorContainer" class="editor-container">
          <div class="file-info" id="fileInfo">
            <div class="file-info-left">
              <i class="fa fa-file-pdf"></i>
              <span class="file-name-text" id="currentFileName"
                >document.pdf</span
              >
            </div>
            <button class="delete-file-btn" id="deleteFileBtn">
              <i class="fa fa-times"></i>
            </button>
          </div>

          <div class="toolbar">
            <button class="tool-btn" id="editPdf">
              <i class="fa fa-pen-to-square"></i> <span>Edit PDF</span>
            </button>

            <button class="tool-btn" id="addTextBtn">
              <i class="fa fa-font"></i> <span>Add Text</span>
              <div class="properties-dropdown" id="textProperties">
                <div class="property-row">
                  <div class="property-item">
                    <label>Size:</label>
                    <input
                      type="number"
                      id="fontSize"
                      min="8"
                      max="72"
                      value="16"
                    />
                  </div>
                  <div class="property-item">
                    <label>Font:</label>
                    <select id="fontFamily">
                      <option value="Arial">Arial</option>
                      <option value="Helvetica">Helvetica</option>
                      <option value="Times New Roman">Times</option>
                      <option value="Courier New">Courier</option>
                      <option value="Georgia">Georgia</option>
                      <option value="Verdana">Verdana</option>
                    </select>
                  </div>
                  <div class="property-item">
                    <label>Color:</label>
                    <div class="color-select">
                      <input type="color" id="textColor" value="#000000" />
                      <input
                        type="text"
                        id="textColorHex"
                        value="#000000"
                        maxlength="7"
                      />
                    </div>
                  </div>
                  <div class="property-item">
                    <label>Weight:</label>
                    <select id="fontWeight">
                      <option value="normal">Normal</option>
                      <option value="bold">Bold</option>
                    </select>
                  </div>
                  <div class="property-item">
                    <label>Style:</label>
                    <select id="fontStyle">
                      <option value="normal">Regular</option>
                      <option value="italic">Italic</option>
                    </select>
                  </div>
                </div>
              </div>
            </button>

            <button class="tool-btn" id="addImageBtn">
              <i class="fa fa-image"></i> <span>Add Image</span>
            </button>

            <!-- DRAW BUTTON + BRUSH OPTION + APPLY DRAWING BUTTON (UI) -->
            <button class="tool-btn" id="drawBtn">
              <i class="fa fa-pencil"></i> <span>Draw</span>
              <!-- BRUSH OPTIONS IN DRAWING PROPERTY (dropdown) -->
              <div class="properties-dropdown" id="drawProperties">
                <div class="property-row">
                  <div class="property-item">
                    <label>Color:</label>
                    <div class="color-select">
                      <input type="color" id="penColor" value="#000000" />
                      <input
                        type="text"
                        id="penColorHex"
                        value="#000000"
                        maxlength="7"
                      />
                    </div>
                  </div>
                  <div class="property-item">
                    <label>Width:</label>
                    <input
                      type="number"
                      id="penWidth"
                      min="1"
                      max="20"
                      value="3"
                    />
                  </div>
                  <!-- BRUSH OPTION: additional style (solid/dotted) -->
                  <div class="property-item">
                    <label>Brush:</label>
                    <select id="brushStyle">
                      <option value="solid">Solid</option>
                      <option value="dotted">Dotted</option>
                      <option value="dashed">Dashed</option>
                    </select>
                  </div>
                  <!-- BRUSH SIZE: dropdown select -->
                  <div class="property-item">
                    <label>Brush Size:</label>
                    <select id="brushSize">
                      <option value="1">1px (Extra Thin)</option>
                      <option value="2">2px (Thin)</option>
                      <option value="3" selected>3px (Medium)</option>
                      <option value="4">4px</option>
                      <option value="5">5px</option>
                      <option value="6">6px (Thick)</option>
                      <option value="8">8px (Extra Thick)</option>
                      <option value="10">10px</option>
                      <option value="12">12px</option>
                      <option value="14">14px</option>
                      <option value="16">16px</option>
                      <option value="18">18px</option>
                      <option value="20">20px</option>
                    </select>
                  </div>
                  <!-- NEW: APPLY DRAWING BUTTON (commits drawing as annotation) -->
                  <div class="property-item">
                    <div class="cta-button" id="applyDrawingBtn">
                      <i class="fa fa-check-circle"></i>
                      <span>Apply Drawing</span>
                    </div>
                  </div>
                </div>
              </div>
            </button>

            <button class="tool-btn" id="addShapeBtn">
              <i class="fa fa-shapes"></i> <span>Add Shape</span>
              <div class="properties-dropdown" id="shapeProperties">
                <div class="property-row">
                  <div class="property-item">
                    <label>Shape:</label>
                    <select id="shapeType">
                      <option value="rectangle">Rectangle</option>
                      <option value="circle">Circle</option>
                      <option value="line">Line</option>
                    </select>
                  </div>
                  <div class="property-item">
                    <label>Fill:</label>
                    <div class="color-select">
                      <input type="color" id="shapeFillColor" value="#4f46e5" />
                      <input
                        type="text"
                        id="shapeFillHex"
                        value="#4f46e5"
                        maxlength="7"
                      />
                    </div>
                  </div>
                  <div class="property-item">
                    <label>Border:</label>
                    <div class="color-select">
                      <input
                        type="color"
                        id="shapeBorderColor"
                        value="#1e3a8a"
                      />
                      <input
                        type="text"
                        id="shapeBorderHex"
                        value="#1e3a8a"
                        maxlength="7"
                      />
                    </div>
                  </div>
                  <div class="property-item">
                    <label>Width:</label>
                    <input
                      type="number"
                      id="shapeBorderWidth"
                      min="0"
                      max="10"
                      value="2"
                    />
                  </div>
                  <div class="property-item">
                    <div class="cta-button" id="applyShapeBtn">
                      <i class="fa fa-check-circle"></i>
                      <span>Apply Shape</span>
                    </div>
                  </div>
                </div>
              </div>
            </button>

            <button class="tool-btn" id="undoBtn">
              <i class="fa fa-undo"></i> <span>Undo</span>
            </button>
            <button class="tool-btn" id="clearAllBtn">
              <i class="fa fa-eraser"></i> <span>Clear All</span>
            </button>
            <button class="tool-btn cta-button" id="saveBtn">
              <i class="fa fa-solid fa-floppy-disk"></i> <span>Save PDF</span>
            </button>
          </div>

          <div class="editor-layout">
            <div class="sidebar">
              <div class="page-thumbnails">
                <h4 class="pages-title"><i class="fa fa-images"></i> Pages</h4>

                <div class="thumbnails-scroll" id="thumbnailContainer"></div>
              </div>
            </div>

            <div class="main-editor">
              <div class="canvas-container" id="canvasContainer"></div>
            </div>
          </div>

          <input type="file" id="imageUpload" accept="image/*" class="hidden" />
        </div>

        <p class="note">
          Supported format: PDF. All editing is done in your browser.
        </p>
      </div>
    </section>

    <section id="footer-placeholder"></section>

    <!-- JS -->
    <script src="./js/app.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Toast Notification System
      const Toast = {
        show: function (message, type = "info", duration = 3000) {
          const container = document.getElementById("toastContainer");
          const toast = document.createElement("div");
          toast.className = `toast ${type}`;

          const icons = {
            success: "fa-check-circle",
            error: "fa-exclamation-circle",
            warning: "fa-exclamation-triangle",
            info: "fa-info-circle",
          };

          const titles = {
            success: "Success",
            error: "Error",
            warning: "Warning",
            info: "Info",
          };

          toast.innerHTML = `
            <i class="fa ${icons[type]} toast-icon"></i>
            <div class="toast-content">
              <div class="toast-title">${titles[type]}</div>
              <div class="toast-message">${message}</div>
            </div>
            <button class="toast-close">&times;</button>
          `;

          container.appendChild(toast);

          const closeBtn = toast.querySelector(".toast-close");
          closeBtn.onclick = () => this.hide(toast);

          if (duration > 0) {
            setTimeout(() => this.hide(toast), duration);
          }

          return toast;
        },

        hide: function (toast) {
          toast.classList.add("hiding");
          setTimeout(() => toast.remove(), 300);
        },

        success: function (message, duration = 3000) {
          return this.show(message, "success", duration);
        },

        error: function (message, duration = 5000) {
          return this.show(message, "error", duration);
        },

        warning: function (message, duration = 4000) {
          return this.show(message, "warning", duration);
        },

        info: function (message, duration = 3000) {
          return this.show(message, "info", duration);
        },
      };

      // Custom Modal System
      const CustomModal = {
        alert: function (message, title = "Notice") {
          return new Promise((resolve) => {
            const overlay = this.createOverlay();
            const modal = this.createModal(title, message, [
              {
                text: "OK",
                class: "custom-modal-btn custom-modal-btn-primary",
                onclick: () => {
                  this.close(overlay);
                  resolve(true);
                },
              },
            ]);

            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            overlay.offsetHeight;
            overlay.classList.add("show");
          });
        },

        confirm: function (message, title = "Confirm", type = "primary") {
          return new Promise((resolve) => {
            const overlay = this.createOverlay();

            let confirmBtnClass = "custom-modal-btn";
            if (type === "danger") {
              confirmBtnClass += " custom-modal-btn-danger";
            } else {
              confirmBtnClass += " custom-modal-btn-primary";
            }

            const modal = this.createModal(title, message, [
              {
                text: "Cancel",
                class: "custom-modal-btn custom-modal-btn-secondary",
                onclick: (e) => {
                  e.stopPropagation();
                  this.close(overlay);
                  resolve(false);
                },
              },
              {
                text: "Confirm",
                class: confirmBtnClass,
                onclick: (e) => {
                  e.stopPropagation();
                  this.close(overlay);
                  resolve(true);
                },
              },
            ]);

            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            overlay.offsetHeight;
            overlay.classList.add("show");
          });
        },

        createOverlay: function () {
          const overlay = document.createElement("div");
          overlay.className = "custom-modal-overlay";
          overlay.style.zIndex = "999999";
          return overlay;
        },

        createModal: function (title, message, buttons) {
          const modal = document.createElement("div");
          modal.className = "custom-modal";
          modal.style.pointerEvents = "auto";

          modal.innerHTML = `
      <div class="custom-modal-header">
        <h3 class="custom-modal-title">${title}</h3>
      </div>
      <div class="custom-modal-body">${message}</div>
      <div class="custom-modal-footer"></div>
    `;

          const footer = modal.querySelector(".custom-modal-footer");
          buttons.forEach((btn) => {
            const button = document.createElement("button");
            button.className = btn.class;
            button.textContent = btn.text;
            button.style.pointerEvents = "auto";
            button.onclick = btn.onclick;
            footer.appendChild(button);
          });

          return modal;
        },

        close: function (overlay) {
          overlay.classList.remove("show");
          setTimeout(() => {
            if (overlay.parentNode) {
              overlay.parentNode.removeChild(overlay);
            }
          }, 300);
        },
      };

      // DOM Elements
      const pdfUpload = document.getElementById("pdfUpload");
      const editorContainer = document.getElementById("editorContainer");
      const canvasContainer = document.getElementById("canvasContainer");
      const thumbnailContainer = document.getElementById("thumbnailContainer");
      const uploadSection = document.getElementById("uploadSection");
      const currentFileName = document.getElementById("currentFileName");
      const deleteFileBtn = document.getElementById("deleteFileBtn");
      const editPdfBtn = document.getElementById("editPdf");

      // Tool buttons
      const addTextBtn = document.getElementById("addTextBtn");
      const addImageBtn = document.getElementById("addImageBtn");
      const drawBtn = document.getElementById("drawBtn");
      const applyDrawingBtn = document.getElementById("applyDrawingBtn");
      const addShapeBtn = document.getElementById("addShapeBtn");
      const undoBtn = document.getElementById("undoBtn");
      const clearAllBtn = document.getElementById("clearAllBtn");
      const saveBtn = document.getElementById("saveBtn");
      const imageUpload = document.getElementById("imageUpload");
      const penColor = document.getElementById("penColor");
      const penWidth = document.getElementById("penWidth");
      const brushStyle = document.getElementById("brushStyle");
      const brushSize = document.getElementById("brushSize");
      const API_BASE_URL = `http://127.0.0.1:8080`;

      // State
      let pdfDoc = null;
      let pdfFile = null;
      let currentTool = null;
      let pages = [];
      let currentPageIndex = 0;
      let selectedAnnotation = null;
      let isDragging = false;
      let isResizing = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let resizeHandle = null;
      let scale = 1;
      let isEditMode = false;
      let ocrTextBlocks = [];
      const MAX_WIDTH = 800;

      class PDFPage {
        constructor(pageNum, canvas, viewport) {
          this.pageNum = pageNum;
          this.canvas = canvas;
          this.viewport = viewport;
          this.annotations = [];
          this.ocrTextBlocks = [];
          this.deletedRegions = [];
          this.deletedImages = [];
          this.drawingCanvas = null;
          this.wrapper = null;
          this.annotationLayer = null;
          this.ocrLayer = null;
          this.scale = 1;
          this.hasDrawing = false;
          this.currentDrawingPaths = [];
        }

        addAnnotation(annotation) {
          this.annotations.push(annotation);
        }

        removeAnnotation(annotation) {
          const index = this.annotations.indexOf(annotation);
          if (index > -1) {
            this.annotations.splice(index, 1);
          }
        }

        addDeletedRegion(region) {
          this.deletedRegions.push(region);
        }
      }

      class Annotation {
        constructor(type, page) {
          this.type = type;
          this.page = page;
          this.element = null;
          this.x = 0;
          this.y = 0;
          this.width = 100;
          this.height = 50;
          this.rotation = 0;
        }

        applyTransform() {
          this.element.style.transform = `rotate(${this.rotation}deg)`;
        }

        createElement() {
          const div = document.createElement("div");
          div.className = "annotation-item";
          div.style.left = this.x + "px";
          div.style.top = this.y + "px";
          div.style.transformOrigin = "center center";
          div.style.width = this.width + "px";
          div.style.height = this.height + "px";

          const controls = document.createElement("div");
          controls.className = "annotation-controls";

          const copyBtn = document.createElement("button");
          copyBtn.className = "control-btn copy-btn";
          copyBtn.innerHTML = '<i class="fa fa-copy"></i>';
          copyBtn.title = "Copy";
          copyBtn.onclick = (e) => {
            e.stopPropagation();
            this.copy();
          };
          controls.appendChild(copyBtn);

          const rotateBtn = document.createElement("button");
          rotateBtn.className = "control-btn rotate-btn";
          rotateBtn.innerHTML = '<i class="fa fa-rotate-right"></i>';
          rotateBtn.title = "Rotate";
          rotateBtn.onclick = (e) => {
            e.stopPropagation();
            this.rotate(15);
          };
          controls.appendChild(rotateBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "control-btn delete-btn";
          deleteBtn.innerHTML = '<i class="fa fa-times"></i>';
          deleteBtn.title = "Delete";
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            this.delete();
          };
          controls.appendChild(deleteBtn);

          div.appendChild(controls);

          ["nw", "ne", "sw", "se"].forEach((pos) => {
            const handle = document.createElement("div");
            handle.className = `resize-handle ${pos}`;
            handle.dataset.handle = pos;
            div.appendChild(handle);
          });

          this.element = div;
          this.attachEvents();
          this.applyTransform();
          return div;
        }

        rotate(deg) {
          this.rotation = (this.rotation + deg) % 360;
          this.applyTransform();
        }

        attachEvents() {
          this.element.addEventListener("mousedown", (e) => {
            if (e.target.classList.contains("resize-handle")) {
              isResizing = true;
              resizeHandle = e.target.dataset.handle;
              e.stopPropagation();
              e.preventDefault();
            } else if (!e.target.closest(".annotation-controls")) {
              isDragging = true;
              const rect = this.page.annotationLayer.getBoundingClientRect();
              dragStartX = e.clientX - rect.left - this.x;
              dragStartY = e.clientY - rect.top - this.y;
              e.stopPropagation();
              e.preventDefault();
            }
            selectAnnotation(this);
          });

          this.element.addEventListener(
            "touchstart",
            (e) => {
              const touch = e.touches[0];

              if (e.target.classList.contains("resize-handle")) {
                isResizing = true;
                resizeHandle = e.target.dataset.handle;
                e.stopPropagation();
                e.preventDefault();
              } else if (!e.target.closest(".annotation-controls")) {
                isDragging = true;
                const rect = this.page.annotationLayer.getBoundingClientRect();
                dragStartX = touch.clientX - rect.left - this.x;
                dragStartY = touch.clientY - rect.top - this.y;
                e.stopPropagation();
                e.preventDefault();
              }
              selectAnnotation(this);
            },
            { passive: false },
          );

          this.element.addEventListener("selectstart", (e) => {
            if (isDragging || isResizing) {
              e.preventDefault();
            }
          });
        }

        updatePosition(x, y) {
          this.x = x;
          this.y = y;
          this.element.style.left = x + "px";
          this.element.style.top = y + "px";
        }

        updateSize(width, height) {
          this.width = Math.max(20, width);
          this.height = Math.max(20, height);
          this.element.style.width = this.width + "px";
          this.element.style.height = this.height + "px";
        }

        delete() {
          this.element.remove();
          this.page.removeAnnotation(this);
          if (selectedAnnotation === this) {
            selectedAnnotation = null;
          }
        }

        copy() {
          const newAnnotation = this.clone();
          newAnnotation.rotation = this.rotation;
          newAnnotation.x += 20;
          newAnnotation.y += 20;
          const element = newAnnotation.createElement();
          newAnnotation.applyTransform();
          this.page.annotationLayer.appendChild(element);
          this.page.addAnnotation(newAnnotation);
          selectAnnotation(newAnnotation);
        }

        clone() {
          return null;
        }
      }

      class TextAnnotation extends Annotation {
        constructor(page, isOCR = false) {
          super("text", page);
          this.text = "Double click to edit";
          this.fontSize = 16;
          this.fontFamily = "Arial";
          this.color = "#000000";
          this.fontWeight = "normal";
          this.fontStyle = "normal";
          this.isOCR = isOCR;
          this.originalData = null;
          this.deletionMarked = false;
        }

        createElement() {
          const wrapper = super.createElement();
          wrapper.classList.add("text-annotation");
          if (this.isOCR) {
            wrapper.classList.add("ocr-text-block");
          }

          const content = document.createElement("div");
          content.className = "text-content";
          content.textContent = this.text;
          content.contentEditable = false;
          content.style.width = "100%";
          content.style.height = "100%";
          content.style.outline = "none";

          content.addEventListener("mousedown", (e) => {
            selectAnnotation(this);
            if (!content.isContentEditable) {
              isDragging = true;
              const rect = this.page.annotationLayer.getBoundingClientRect();
              dragStartX = e.clientX - rect.left - this.x;
              dragStartY = e.clientY - rect.top - this.y;
              e.preventDefault();
            }
          });

          content.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            content.contentEditable = true;
            content.style.cursor = "text";
            wrapper.classList.add("editing");
            content.focus();

            const range = document.createRange();
            range.selectNodeContents(content);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          });

          content.addEventListener("input", () => {
            this.text = content.innerText;
          });

          content.addEventListener("blur", () => {
            content.contentEditable = false;
            this.text = content.innerText;
            content.style.cursor = "move";
            wrapper.classList.remove("editing");

            if (this.isOCR && this.originalData && !this.deletionMarked) {
              this.page.addDeletedRegion({
                x: this.originalData.x,
                y: this.originalData.y,
                width: this.originalData.width,
                height: this.originalData.height,
              });
              this.deletionMarked = true;
            }
          });
          wrapper.appendChild(content);
          this.applyStyles();
          return wrapper;
        }

        applyStyles() {
          this.element.style.fontSize = this.fontSize + "px";
          this.element.style.fontFamily = this.fontFamily;
          this.element.style.color = this.color;
          this.element.style.fontWeight = this.fontWeight;
          this.element.style.fontStyle = this.fontStyle;
        }

        updateProperty(prop, value) {
          this[prop] = value;
          this.applyStyles();
        }

        clone() {
          const newAnnotation = new TextAnnotation(this.page, false);
          newAnnotation.text = this.text;
          newAnnotation.fontSize = this.fontSize;
          newAnnotation.fontFamily = this.fontFamily;
          newAnnotation.color = this.color;
          newAnnotation.fontWeight = this.fontWeight;
          newAnnotation.fontStyle = this.fontStyle;
          newAnnotation.width = this.width;
          newAnnotation.height = this.height;
          return newAnnotation;
        }

        updatePosition(x, y) {
          super.updatePosition(x, y);
          if (this.isOCR && this.originalData && !this.deletionMarked) {
            this.page.addDeletedRegion({
              x: this.originalData.x,
              y: this.originalData.y,
              width: this.originalData.width,
              height: this.originalData.height,
            });
            this.deletionMarked = true;
          }
        }

        updateSize(width, height) {
          super.updateSize(width, height);
          if (this.isOCR && this.originalData && !this.deletionMarked) {
            this.page.addDeletedRegion({
              x: this.originalData.x,
              y: this.originalData.y,
              width: this.originalData.width,
              height: this.originalData.height,
            });
            this.deletionMarked = true;
          }
        }
      }

      class ImageAnnotation extends Annotation {
        constructor(page, imageSrc) {
          super("image", page);
          this.imageSrc = imageSrc;
          this.width = 150;
          this.height = 150;
          this.isOriginal = false;
          this.originalImageData = null;
          this.deletionMarked = false;
        }

        createElement() {
          const div = super.createElement();
          div.classList.add("image-annotation");
          const img = document.createElement("img");
          img.src = this.imageSrc;
          img.draggable = false;
          div.appendChild(img);
          return div;
        }

        clone() {
          const newAnnotation = new ImageAnnotation(this.page, this.imageSrc);
          newAnnotation.width = this.width;
          newAnnotation.height = this.height;
          return newAnnotation;
        }

        updatePosition(x, y) {
          super.updatePosition(x, y);
          if (
            this.isOriginal &&
            this.originalImageData &&
            !this.deletionMarked
          ) {
            if (!this.page.deletedImages) {
              this.page.deletedImages = [];
            }
            this.page.deletedImages.push(this.originalImageData);
            this.deletionMarked = true;
            this.isOriginal = false;
          }
        }

        updateSize(width, height) {
          super.updateSize(width, height);
          if (
            this.isOriginal &&
            this.originalImageData &&
            !this.deletionMarked
          ) {
            if (!this.page.deletedImages) {
              this.page.deletedImages = [];
            }
            this.page.deletedImages.push(this.originalImageData);
            this.deletionMarked = true;
            this.isOriginal = false;
          }
        }

        delete() {
          this.element.remove();
          this.page.removeAnnotation(this);

          if (
            this.isOriginal &&
            this.originalImageData &&
            !this.deletionMarked
          ) {
            if (!this.page.deletedImages) {
              this.page.deletedImages = [];
            }
            this.page.deletedImages.push(this.originalImageData);
            this.deletionMarked = true;
          }

          if (selectedAnnotation === this) {
            selectedAnnotation = null;
          }
        }
      }

      class ShapeAnnotation extends Annotation {
        constructor(page, shapeType) {
          super("shape", page);
          this.shapeType = shapeType;
          this.fillColor = "#4f46e5";
          this.borderColor = "#1e3a8a";
          this.borderWidth = 2;
        }

        createElement() {
          const div = super.createElement();
          div.classList.add("shape-annotation");
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.style.width = "100%";
          svg.style.height = "100%";
          svg.style.pointerEvents = "auto";
          svg.style.userSelect = "none";

          this.svg = svg;
          this.updateShape();
          div.appendChild(svg);
          return div;
        }

        updateShape() {
          this.svg.innerHTML = "";

          if (this.shapeType === "rectangle") {
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect",
            );
            rect.setAttribute("width", "100%");
            rect.setAttribute("height", "100%");
            rect.setAttribute("fill", this.fillColor);
            rect.setAttribute("stroke", this.borderColor);
            rect.setAttribute("stroke-width", this.borderWidth);
            this.svg.appendChild(rect);
          } else if (this.shapeType === "circle") {
            const circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle",
            );
            circle.setAttribute("cx", "50%");
            circle.setAttribute("cy", "50%");
            circle.setAttribute("r", "45%");
            circle.setAttribute("fill", this.fillColor);
            circle.setAttribute("stroke", this.borderColor);
            circle.setAttribute("stroke-width", this.borderWidth);
            this.svg.appendChild(circle);
          } else if (this.shapeType === "line") {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line",
            );
            line.setAttribute("x1", "0");
            line.setAttribute("y1", "50%");
            line.setAttribute("x2", "100%");
            line.setAttribute("y2", "50%");
            line.setAttribute("stroke", this.borderColor);
            line.setAttribute("stroke-width", this.borderWidth);
            this.svg.appendChild(line);
          }
        }

        updateProperty(prop, value) {
          this[prop] = value;
          this.updateShape();
        }

        clone() {
          const newAnnotation = new ShapeAnnotation(this.page, this.shapeType);
          newAnnotation.fillColor = this.fillColor;
          newAnnotation.borderColor = this.borderColor;
          newAnnotation.borderWidth = this.borderWidth;
          newAnnotation.width = this.width;
          newAnnotation.height = this.height;
          return newAnnotation;
        }
      }

      class DrawingAnnotation extends Annotation {
        constructor(page, pathData, color, width, brushStyle = "solid") {
          super("drawing", page);
          this.pathData = pathData;
          this.color = color;
          this.strokeWidth = width;
          this.brushStyle = brushStyle;
        }

        createElement() {
          const div = super.createElement();
          div.classList.add("shape-annotation");

          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");

          const points =
            this.pathData.match(/[ML]\s*([\d.]+)\s*([\d.]+)/g) || [];
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

          points.forEach((p) => {
            const parts = p.match(/[\d.]+/g);
            if (parts && parts.length >= 2) {
              const x = parseFloat(parts[0]);
              const y = parseFloat(parts[1]);
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          });

          const margin = 2;
          const viewBoxWidth = maxX - minX + margin * 2;
          const viewBoxHeight = maxY - minY + margin * 2;
          const viewBoxX = minX - margin;
          const viewBoxY = minY - margin;

          svg.setAttribute(
            "viewBox",
            `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`,
          );

          svg.setAttribute("preserveAspectRatio", "none");

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );

          path.setAttribute("d", this.pathData);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", this.color);

          const scaleX = this.width / viewBoxWidth;
          const scaleY = this.height / viewBoxHeight;
          const scale = Math.max(scaleX, scaleY);

          path.setAttribute("stroke-width", this.strokeWidth / scale);
          path.setAttribute("stroke-linecap", "round");
          path.setAttribute("stroke-linejoin", "round");

          if (this.brushStyle === "dotted") {
            path.setAttribute("stroke-dasharray", "2 4");
          } else if (this.brushStyle === "dashed") {
            path.setAttribute("stroke-dasharray", "9 5");
          }

          svg.appendChild(path);
          div.appendChild(svg);

          return div;
        }

        clone() {
          const clone = new DrawingAnnotation(
            this.page,
            this.pathData,
            this.color,
            this.strokeWidth,
            this.brushStyle,
          );
          clone.x = this.x;
          clone.y = this.y;
          clone.width = this.width;
          clone.height = this.height;
          clone.rotation = this.rotation;
          return clone;
        }
      }

      // Event Listeners
      pdfUpload.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        pdfFile = file;
        currentFileName.textContent = file.name;
        const loader = document.getElementById("uploadLoader");
        loader.style.display = "block";

        try {
          await loadPDF(file);
          loader.style.display = "none";
          Toast.success("PDF loaded successfully!");
        } catch (err) {
          console.error("PDF load error:", err);
          Toast.error("Failed to load PDF. Please try another file.");
        } finally {
          loader.style.display = "none";
        }
      });

      async function loadPDF(file) {
        editorContainer.style.display = "block";
        uploadSection.style.display = "none";
        const arrayBuffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

        canvasContainer.innerHTML = "";
        thumbnailContainer.innerHTML = "";
        pages = [];

        for (let i = 1; i <= pdfDoc.numPages; i++) {
          const page = await pdfDoc.getPage(i);

          const baseViewport = page.getViewport({ scale: 1 });

          const containerRect = canvasContainer.getBoundingClientRect();
          const containerWidth = containerRect.width || MAX_WIDTH;
          const maxWidth = Math.min(containerWidth - 40, MAX_WIDTH);

          const displayScale = maxWidth / baseViewport.width;

          const renderScale = displayScale * (window.devicePixelRatio || 2);
          const renderViewport = page.getViewport({ scale: renderScale });

          const wrapper = document.createElement("div");
          wrapper.className = "pdf-page-wrapper";
          wrapper.style.width = baseViewport.width * displayScale + "px";
          wrapper.style.height = baseViewport.height * displayScale + "px";
          if (i === 1) wrapper.classList.add("active");

          const canvas = document.createElement("canvas");
          canvas.className = "pdf-canvas";
          canvas.width = renderViewport.width;
          canvas.height = renderViewport.height;

          canvas.style.width = baseViewport.width * displayScale + "px";
          canvas.style.height = baseViewport.height * displayScale + "px";

          const context = canvas.getContext("2d");
          await page.render({
            canvasContext: context,
            viewport: renderViewport,
          }).promise;

          const annotationLayer = document.createElement("div");
          annotationLayer.className = "annotation-layer";
          annotationLayer.style.width =
            baseViewport.width * displayScale + "px";
          annotationLayer.style.height =
            baseViewport.height * displayScale + "px";

          const ocrLayer = document.createElement("div");
          ocrLayer.className = "ocr-layer";
          ocrLayer.style.width = baseViewport.width * displayScale + "px";
          ocrLayer.style.height = baseViewport.height * displayScale + "px";
          ocrLayer.style.position = "absolute";
          ocrLayer.style.top = "0";
          ocrLayer.style.left = "0";
          ocrLayer.style.pointerEvents = "none";

          const drawingCanvas = document.createElement("canvas");
          drawingCanvas.className = "drawing-canvas";
          drawingCanvas.width = renderViewport.width;
          drawingCanvas.height = renderViewport.height;
          drawingCanvas.style.width = baseViewport.width * displayScale + "px";
          drawingCanvas.style.height =
            baseViewport.height * displayScale + "px";

          wrapper.appendChild(canvas);
          wrapper.appendChild(ocrLayer);
          wrapper.appendChild(annotationLayer);
          wrapper.appendChild(drawingCanvas);
          canvasContainer.appendChild(wrapper);

          const thumbViewport = page.getViewport({ scale: 0.2 });
          const thumbCanvas = document.createElement("canvas");
          thumbCanvas.width = thumbViewport.width;
          thumbCanvas.height = thumbViewport.height;
          const thumbContext = thumbCanvas.getContext("2d");
          await page.render({
            canvasContext: thumbContext,
            viewport: thumbViewport,
          }).promise;

          const thumbItem = document.createElement("div");
          thumbItem.className = "thumbnail-item";
          if (i === 1) thumbItem.classList.add("active");
          thumbItem.dataset.page = i - 1;
          thumbItem.appendChild(thumbCanvas);

          const pageLabel = document.createElement("div");
          pageLabel.className = "page-label";
          pageLabel.textContent = `Page ${i}`;
          thumbItem.appendChild(pageLabel);

          thumbItem.addEventListener("click", () => switchToPage(i - 1));
          thumbnailContainer.appendChild(thumbItem);

          const displayViewport = page.getViewport({ scale: displayScale });
          const pdfPage = new PDFPage(i, canvas, displayViewport);
          pdfPage.wrapper = wrapper;
          pdfPage.annotationLayer = annotationLayer;
          pdfPage.ocrLayer = ocrLayer;
          pdfPage.drawingCanvas = drawingCanvas;
          pdfPage.scale = displayScale;
          pages.push(pdfPage);

          setupDrawing(pdfPage);
        }

        editorContainer.style.display = "block";
        uploadSection.style.display = "none";
      }

      // Edit PDF Button - Extract text using OCR
      editPdfBtn.addEventListener("click", async () => {
        if (!pdfFile) {
          await CustomModal.alert("Please upload a PDF first", "Notice");
          return;
        }

        if (isEditMode) {
          await CustomModal.alert("Edit mode is already active", "Notice");
          return;
        }

        editPdfBtn.disabled = true;
        editPdfBtn.innerHTML =
          '<i class="fa fa-spinner fa-spin"></i> <span>Extracting Text...</span>';

        try {
          const formData = new FormData();
          formData.append("file", pdfFile);

          // Call backend OCR extraction (which NOW also deletes originals)
          const response = await fetch(`${API_BASE_URL}/extract-text-ocr`, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          if (data.success) {
            console.log("✅ Received OCR data and cleaned PDF");

            // Clear existing OCR layers
            pages.forEach((page) => {
              page.ocrTextBlocks = [];
              page.ocrLayer.innerHTML = "";
            });

            // Display the DUPLICATE text and images as overlays
            displayOCRText(data.pages);
            displayOCRImages(data.pages);

            // ⭐ CRITICAL: Reload PDF with deletions applied
            await reloadCleanedPDF(data.cleanedPdf);

            isEditMode = true;
            editPdfBtn.innerHTML =
              '<i class="fa fa-check"></i> <span>Edit Mode Active</span>';
            editPdfBtn.classList.add("active");
            Toast.success(
              "Edit mode activated! Original content deleted from view.",
            );
          } else {
            Toast.error(
              "Error extracting text: " + (data.error || "Unknown error"),
            );
            editPdfBtn.innerHTML =
              '<i class="fa fa-pen-to-square"></i> <span>Edit PDF</span>';
            editPdfBtn.disabled = false;
          }
        } catch (error) {
          console.error("Error:", error);
          Toast.error(
            "Failed to extract text from PDF. Make sure Flask server is running on port 8080.",
          );
          editPdfBtn.innerHTML =
            '<i class="fa fa-pen-to-square"></i> <span>Edit PDF</span>';
          editPdfBtn.disabled = false;
        }
      });

      async function reloadCleanedPDF(cleanedPdfBase64) {
        try {
          console.log("🔄 Reloading PDF with deletions applied...");

          // Convert base64 to ArrayBuffer
          const binaryString = atob(cleanedPdfBase64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const arrayBuffer = bytes.buffer;

          // CRITICAL FIX: Create a NEW File object from the cleaned PDF
          const cleanedBlob = new Blob([arrayBuffer], {
            type: "application/pdf",
          });

          // IMPORTANT: Create a new File with the SAME name but NEW content
          const cleanedFile = new File([cleanedBlob], pdfFile.name, {
            type: "application/pdf",
            lastModified: Date.now(),
          });

          // Replace the pdfFile with the cleaned version
          pdfFile = cleanedFile;

          // Reload PDF.js with cleaned PDF
          pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          // Re-render all canvases with the cleaned PDF
          for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const pdfPage = await pdfDoc.getPage(i + 1);

            // Use the same scale as before
            const renderScale = page.scale * (window.devicePixelRatio || 2);
            const renderViewport = pdfPage.getViewport({ scale: renderScale });

            // Clear the canvas
            const ctx = page.canvas.getContext("2d");
            ctx.clearRect(0, 0, page.canvas.width, page.canvas.height);

            // Re-render with cleaned PDF (originals now deleted)
            await pdfPage.render({
              canvasContext: ctx,
              viewport: renderViewport,
            }).promise;
          }

          console.log("✅ PDF reloaded successfully - deletions now visible!");
        } catch (error) {
          console.error("❌ Error reloading cleaned PDF:", error);
          Toast.warning(
            "Could not reload PDF preview, but deletions will apply on save",
          );
        }
      }

      function displayOCRText(pagesData) {
        pagesData.forEach((pageData, index) => {
          const page = pages[index];
          if (!page) return;

          page.ocrTextBlocks = [];
          page.ocrLayer.innerHTML = "";
          page.ocrLayer.style.pointerEvents = "auto";

          pageData.textBlocks.forEach((block) => {
            const annotation = new TextAnnotation(page, true);
            annotation.text = block.text;
            annotation.x = block.x * page.scale;
            annotation.y = block.y * page.scale;

            // FIX: Better width and height calculation
            // Ensure minimum width to prevent text wrapping issues
            const minWidth = 50;
            annotation.width = Math.max(block.width * page.scale, minWidth);

            // FIX: Better height calculation to accommodate text properly
            // Use 1.5x the font size as minimum height to prevent text cutoff
            const calculatedHeight = block.height * page.scale;
            const minHeightFromFont = block.fontSize * page.scale * 1.5;
            annotation.height = Math.max(
              calculatedHeight,
              minHeightFromFont,
              20,
            );

            annotation.fontSize = Math.round(block.fontSize * page.scale);
            annotation.fontFamily = block.fontFamily || "Arial";
            annotation.color = block.color || "#000000";

            // FIX: Add font weight and style from backend
            annotation.fontWeight = block.fontWeight || "normal";
            annotation.fontStyle = block.fontStyle || "normal";

            annotation.deletionMarked = false;

            annotation.originalData = {
              x: block.x,
              y: block.y,
              width: block.width,
              height: block.height,
            };

            const element = annotation.createElement();

            // FIX: Add CSS to prevent text wrapping and ensure proper display
            const textContent = element.querySelector(".text-content");
            if (textContent) {
              textContent.style.whiteSpace = "nowrap";
              textContent.style.overflow = "visible";
              textContent.style.textOverflow = "clip";
              textContent.style.display = "block";
              textContent.style.lineHeight = "1.2";
            }

            page.ocrLayer.appendChild(element);
            page.ocrTextBlocks.push(annotation);
          });
        });
      }

      function displayOCRImages(pagesData) {
        pagesData.forEach((pageData, index) => {
          const page = pages[index];
          if (!page) return;

          pageData.images.forEach((img) => {
            createEditableImage(page, img, pageData.pdfId);
          });
        });
      }

      async function createEditableImage(page, imgInfo, pdfId) {
        const annotation = new ImageAnnotation(page, "");
        annotation.x = imgInfo.x * page.scale;
        annotation.y = imgInfo.y * page.scale;
        annotation.width = imgInfo.width * page.scale;
        annotation.height = imgInfo.height * page.scale;
        annotation.xref = imgInfo.xref;
        annotation.isOriginal = true;

        try {
          const response = await fetch(`${API_BASE_URL}/get-pdf-image`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              xref: imgInfo.xref,
              pageNum: imgInfo.pageNum,
              pdfId: pdfId,
            }),
          });

          if (response.ok) {
            const blob = await response.blob();
            const imageUrl = URL.createObjectURL(blob);
            annotation.imageSrc = imageUrl;
            annotation.originalImageData = {
              xref: imgInfo.xref,
              x: imgInfo.x,
              y: imgInfo.y,
              width: imgInfo.width,
              height: imgInfo.height,
            };

            const element = annotation.createElement();
            page.ocrLayer.appendChild(element);

            page.ocrTextBlocks.push(annotation);
          }
        } catch (error) {
          console.error("Error loading image:", error);
        }
      }

      // Save PDF with changes - MODIFIED to show download, share, reset buttons AND PDF PREVIEW
      saveBtn.addEventListener("click", async () => {
        if (!pdfFile) {
          await CustomModal.alert("No PDF loaded", "Notice");
          return;
        }

        saveBtn.disabled = true;
        saveBtn.innerHTML =
          '<i class="fa fa-spinner fa-spin"></i> <span>Saving...</span>';

        try {
          const formData = new FormData();

          // CRITICAL FIX: Make sure pdfFile is valid
          if (!pdfFile || pdfFile.size === 0) {
            throw new Error("PDF file is empty or invalid");
          }

          formData.append("file", pdfFile);

          const annotationsData = await Promise.all(
            pages.map(async (page) => {
              const pageAnnotations = [];

              // Process regular annotations
              for (const ann of page.annotations) {
                const annData = {
                  type: ann.type,
                  x: ann.x / page.scale,
                  y: ann.y / page.scale,
                  width: ann.width / page.scale,
                  height: ann.height / page.scale,
                  rotation: ann.rotation || 0,
                };

                if (ann.type === "text") {
                  annData.text = ann.text;
                  annData.fontSize = ann.fontSize / page.scale;
                  annData.fontFamily = ann.fontFamily;
                  annData.color = ann.color;
                  annData.fontWeight = ann.fontWeight;
                  annData.fontStyle = ann.fontStyle;
                } else if (ann.type === "image") {
                  if (ann.imageSrc && ann.imageSrc.startsWith("blob:")) {
                    try {
                      const response = await fetch(ann.imageSrc);
                      const blob = await response.blob();
                      const base64 = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                      });
                      annData.imageData = base64;
                    } catch (err) {
                      console.error("Error converting blob to base64:", err);
                      continue;
                    }
                  } else {
                    annData.imageData = ann.imageSrc;
                  }
                } else if (ann.type === "shape") {
                  annData.shapeType = ann.shapeType;
                  annData.fillColor = ann.fillColor;
                  annData.borderColor = ann.borderColor;
                  annData.borderWidth = ann.borderWidth / page.scale;
                } else if (ann.type === "drawing") {
                  const scaledPath = ann.pathData.replace(
                    /([ML])\s*([\d.]+)\s*([\d.]+)/g,
                    (match, cmd, x, y) => {
                      const pdfX = parseFloat(x) / page.scale;
                      const pdfY = parseFloat(y) / page.scale;
                      return `${cmd} ${pdfX} ${pdfY}`;
                    },
                  );
                  annData.pathData = scaledPath;
                  annData.color = ann.color;
                  annData.strokeWidth = ann.strokeWidth / page.scale;
                  annData.brushStyle = ann.brushStyle;
                }

                pageAnnotations.push(annData);
              }

              // Process OCR text blocks
              for (const ann of page.ocrTextBlocks) {
                if (ann.element && ann.element.parentNode) {
                  const annData = {
                    type: ann.type,
                    x: ann.x / page.scale,
                    y: ann.y / page.scale,
                    width: ann.width / page.scale,
                    height: ann.height / page.scale,
                  };

                  if (ann.type === "text") {
                    annData.text = ann.text;
                    annData.fontSize = ann.fontSize / page.scale;
                    annData.fontFamily = ann.fontFamily;
                    annData.color = ann.color;
                    annData.fontWeight = ann.fontWeight;
                    annData.fontStyle = ann.fontStyle;
                  } else if (ann.type === "image") {
                    if (ann.imageSrc && ann.imageSrc.startsWith("blob:")) {
                      try {
                        const response = await fetch(ann.imageSrc);
                        const blob = await response.blob();
                        const base64 = await new Promise((resolve) => {
                          const reader = new FileReader();
                          reader.onloadend = () => resolve(reader.result);
                          reader.readAsDataURL(blob);
                        });
                        annData.imageData = base64;
                      } catch (err) {
                        console.error(
                          "Error converting OCR image blob to base64:",
                          err,
                        );
                        continue;
                      }
                    } else {
                      annData.imageData = ann.imageSrc;
                    }
                  }

                  pageAnnotations.push(annData);
                }
              }

              let drawingData = null;
              if (page.hasDrawing) {
                const ctx = page.drawingCanvas.getContext("2d");
                const imageData = ctx.getImageData(
                  0,
                  0,
                  page.drawingCanvas.width,
                  page.drawingCanvas.height,
                );
                const hasDrawing = imageData.data.some(
                  (channel) => channel !== 0,
                );

                if (hasDrawing) {
                  drawingData = page.drawingCanvas.toDataURL("image/png");
                }
              }

              return {
                pageNum: page.pageNum,
                annotations: pageAnnotations,
                deletedRegions: page.deletedRegions || [],
                deletedImages: page.deletedImages || [],
                drawing: drawingData,
              };
            }),
          );

          formData.append("annotations", JSON.stringify(annotationsData));

          const response = await fetch(`${API_BASE_URL}/edit-pdf`, {
            method: "POST",
            body: formData,
          });

          if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);

            // STORE THE PDF DATA FOR SHARE/RESET FUNCTIONALITY
            const savedPdfUrl = url;
            const fileName = "edited_" + currentFileName.textContent;

            // HIDE EDITOR INTERFACE
            editorContainer.style.display = "none";
            uploadSection.style.display = "none";

            // HIDE NOTE
            const noteElement = document.querySelector(".note");
            if (noteElement) noteElement.style.display = "none";

            // CREATE OR SHOW RESULT SECTION WITH PREVIEW
            let resultSection = document.getElementById("resultSection");

            if (!resultSection) {
              // Create result section if it doesn't exist
              resultSection = document.createElement("div");
              resultSection.id = "resultSection";
              resultSection.className = "result-section";

              // Insert after editor container or at appropriate location
              const container = document.querySelector(
                ".merge-tool .container",
              );
              container.appendChild(resultSection);
            }

            // Check if it's a desktop device (for preview)
            const isSmallDevice =
              window.matchMedia("(max-width: 768px)").matches;

            // Style and populate the result section
            resultSection.innerHTML = `
        <div style="display: flex; flex-direction: column; align-items: center; gap: 24px; width: 100%;">
          <!-- Success Header -->
          <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; width: 100%;">
            <div style="background: #e8f5e9; padding: 20px; border-radius: 50%; width: 80px; height: 80px; display: flex; align-items: center; justify-content: center;">
              <i class="fa fa-check-circle" style="font-size: 48px; color: #4caf50;"></i>
            </div>
            <h2 style="color: #1f2937; margin: 0; font-size: 28px;">PDF Saved Successfully!</h2>
            <p style="color: #6b7280; margin: 0; font-size: 16px;">Your edited PDF is ready to download and share.</p>
          </div>
          
          <!-- Result Card (like reference) -->
          <div style="background: white; border-radius: 12px; padding: 24px; width: 100%; max-width: 800px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
            <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 20px;">
              <div style="background: #fee2e2; padding: 12px; border-radius: 8px;">
                <i class="fa fa-file-pdf" style="font-size: 32px; color: #ef4444;"></i>
              </div>
              <div style="flex: 1;">
                <h3 style="color: #1f2937; margin: 0 0 4px 0; font-size: 18px;">${fileName}</h3>
                <p style="color: #6b7280; margin: 0; font-size: 14px;">${(blob.size / 1024).toFixed(2)} KB • Edited PDF</p>
              </div>
            </div>
            
            <!-- Action Buttons - EXACTLY LIKE REFERENCE -->
            <div style="display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; margin-bottom: 20px;">
              <a href="${savedPdfUrl}" download="${fileName}" 
                 style="display: inline-flex; align-items: center; gap: 10px; background: #4f46e5; color: white; padding: 12px 28px; border-radius: 8px; text-decoration: none; font-weight: 500; transition: all 0.2s; border: none; cursor: pointer;">
                <i class="fa fa-download"></i> Download
              </a>
              
              <button onclick="sharePDF('${savedPdfUrl}', '${fileName}')" 
                      style="display: inline-flex; align-items: center; gap: 10px; background: #10b981; color: white; border: none; padding: 12px 28px; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.2s;">
                <i class="fa fa-share-alt"></i> Share
              </button>
              
              <button onclick="resetPDFEditor()" 
                      style="display: inline-flex; align-items: center; gap: 10px; background: white; color: #4b5563; border: 1px solid #e5e7eb; padding: 12px 28px; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.2s;">
                <i class="fa fa-rotate-right"></i> Add Another Watermark
              </button>
            </div>
            
            <p style="color: #9ca3af; font-size: 14px; text-align: center; margin: 0; padding-top: 16px; border-top: 1px solid #e5e7eb;">
              <i class="fa fa-clock"></i> Your file will be automatically deleted after 1 hour
            </p>
          </div>
          
          <!-- PDF PREVIEW SECTION - FOR DESKTOP (EXACTLY LIKE REFERENCE) -->
          ${
            !isSmallDevice
              ? `
          <div id="pdfPreview" style="width: 100%; max-width: 900px; margin-top: 20px;">
            <h3 style="color: #1f2937; margin-bottom: 16px; text-align: left; font-size: 20px;">Preview</h3>
            <div style="background: white; border-radius: 12px; padding: 4px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
              <iframe 
                id="pdfFrame"
                src="${savedPdfUrl}"
                width="100%" 
                height="600" 
                style="border-radius: 8px; border: none; display: block;"
                title="Edited PDF preview"
              ></iframe>
            </div>
          </div>
          `
              : ""
          }
        </div>
      `;

            resultSection.style.display = "block";

            // Add share functionality to window
            window.sharePDF = function (url, filename) {
              if (navigator.share) {
                fetch(url)
                  .then((res) => res.blob())
                  .then((blob) => {
                    const file = new File([blob], filename, {
                      type: "application/pdf",
                    });
                    navigator
                      .share({
                        title: "Edited PDF",
                        text: "Check out my edited PDF",
                        files: [file],
                      })
                      .catch((error) => {
                        console.log("Share failed:", error);
                        // Fallback: copy link
                        const textarea = document.createElement("textarea");
                        textarea.value = url;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand("copy");
                        document.body.removeChild(textarea);
                        Toast.success("Download link copied to clipboard!");
                      });
                  });
              } else {
                // Fallback for browsers that don't support Web Share API
                const textarea = document.createElement("textarea");
                textarea.value = url;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand("copy");
                document.body.removeChild(textarea);
                Toast.success("Download link copied to clipboard!");
              }
            };

            // Add reset functionality to window - FIXED to show save button
            window.resetPDFEditor = function () {
              // Hide result section
              document.getElementById("resultSection").style.display = "none";

              // Reset all state
              pdfDoc = null;
              pdfFile = null;
              pages = [];
              currentPageIndex = 0;
              selectedAnnotation = null;
              isEditMode = false;

              // Reset file input
              pdfUpload.value = "";

              // Show upload section
              editorContainer.style.display = "none";
              uploadSection.style.display = "flex";

              // Show note
              const noteElement = document.querySelector(".note");
              if (noteElement) noteElement.style.display = "block";

              // Clear containers
              canvasContainer.innerHTML = "";
              thumbnailContainer.innerHTML = "";

              // Reset filename
              currentFileName.textContent = "document.pdf";

              // Reset edit button
              editPdfBtn.innerHTML =
                '<i class="fa fa-pen-to-square"></i> <span>Edit PDF</span>';
              editPdfBtn.disabled = false;
              editPdfBtn.classList.remove("active");

              // Reset tool states
              currentTool = null;
              document
                .querySelectorAll(".tool-btn")
                .forEach((btn) => btn.classList.remove("active"));

              // SHOW THE SAVE BUTTON AGAIN
              saveBtn.style.display = "inline-flex";
              saveBtn.disabled = false;
              saveBtn.innerHTML =
                '<i class="fa fa-solid fa-floppy-disk"></i> <span>Save PDF</span>';

              // Clear drawing states on pages
              pages.forEach((page) => {
                if (page.drawingCanvas) {
                  const ctx = page.drawingCanvas.getContext("2d");
                  ctx.clearRect(
                    0,
                    0,
                    page.drawingCanvas.width,
                    page.drawingCanvas.height,
                  );
                  page.hasDrawing = false;
                  page.currentDrawingPaths = [];
                }
              });

              Toast.success("Ready to edit another PDF");
            };

            Toast.success("PDF saved successfully!");

            // Hide the save button after successful save
            saveBtn.style.display = "none";

            // Scroll to top smoothly like reference
            window.scrollTo({ top: 0, behavior: "smooth" });
          } else {
            let errorMessage = "Error saving PDF";
            try {
              const error = await response.json();
              errorMessage = error.error || errorMessage;
            } catch {
              errorMessage = response.statusText || errorMessage;
            }
            Toast.error(errorMessage);

            // Make sure save button is visible if there's an error
            saveBtn.style.display = "inline-flex";
          }
        } catch (error) {
          console.error("Error:", error);
          Toast.error("Failed to save PDF: " + error.message);

          // Make sure save button is visible if there's an error
          saveBtn.style.display = "inline-flex";
        } finally {
          saveBtn.disabled = false;
          saveBtn.innerHTML =
            '<i class="fa fa-solid fa-floppy-disk"></i> <span>Save PDF</span>';
        }
      });

      function switchToPage(index) {
        currentPageIndex = index;

        pages.forEach((page, i) => {
          if (i === index) {
            page.wrapper.classList.add("active");
          } else {
            page.wrapper.classList.remove("active");
          }
        });

        document.querySelectorAll(".thumbnail-item").forEach((thumb, i) => {
          if (i === index) {
            thumb.classList.add("active");
          } else {
            thumb.classList.remove("active");
          }
        });

        const activeThumb = thumbnailContainer.children[index];
        if (activeThumb) {
          activeThumb.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
            inline: "center",
          });
        }
      }

      function setupDrawing(page) {
        const canvas = page.drawingCanvas;
        const ctx = canvas.getContext("2d");

        let isDrawing = false;
        let points = [];

        function getCoords(e, canvas) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          if (e.touches && e.touches.length > 0) {
            return {
              x: (e.touches[0].clientX - rect.left) * scaleX,
              y: (e.touches[0].clientY - rect.top) * scaleY,
            };
          }

          return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY,
          };
        }

        function startStroke(e) {
          if (currentTool !== "draw") return;
          e.preventDefault();

          isDrawing = true;
          points = [];

          const coords = getCoords(e, canvas);
          points.push({ x: coords.x, y: coords.y });

          ctx.strokeStyle = penColor.value;
          ctx.lineWidth = parseInt(brushSize.value);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          const brush = brushStyle.value;
          if (brush === "dotted") {
            ctx.setLineDash([2, 4]);
          } else if (brush === "dashed") {
            ctx.setLineDash([8, 6]);
          } else {
            ctx.setLineDash([]);
          }

          ctx.beginPath();
          ctx.moveTo(coords.x, coords.y);
        }

        function drawStroke(e) {
          if (!isDrawing || currentTool !== "draw") return;
          e.preventDefault();

          const coords = getCoords(e, canvas);
          points.push({ x: coords.x, y: coords.y });

          ctx.lineTo(coords.x, coords.y);
          ctx.stroke();

          page.hasDrawing = true;
        }

        function endStroke(e) {
          if (!isDrawing) return;
          e.preventDefault();
          isDrawing = false;
          ctx.closePath();
          ctx.setLineDash([]);

          if (points.length > 1) {
            let pathData = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
              pathData += ` L ${points[i].x} ${points[i].y}`;
            }

            if (!page.currentDrawingPaths) {
              page.currentDrawingPaths = [];
            }

            page.currentDrawingPaths.push({
              pathData: pathData,
              color: penColor.value,
              width: parseInt(brushSize.value),
              brushStyle: brushStyle.value,
            });

            page.hasDrawing = true;
          }
        }

        canvas.addEventListener("mousedown", startStroke);
        canvas.addEventListener("mousemove", drawStroke);
        canvas.addEventListener("mouseup", endStroke);
        canvas.addEventListener("mouseleave", endStroke);

        canvas.addEventListener("touchstart", startStroke, { passive: false });
        canvas.addEventListener("touchmove", drawStroke, { passive: false });
        canvas.addEventListener("touchend", endStroke, { passive: false });
        canvas.addEventListener("touchcancel", endStroke, { passive: false });
      }

      // APPLY DRAWING BUTTON
      applyDrawingBtn.addEventListener("click", () => {
        const page = pages[currentPageIndex];

        if (
          page.hasDrawing &&
          page.currentDrawingPaths &&
          page.currentDrawingPaths.length > 0
        ) {
          page.currentDrawingPaths.forEach((drawingPath) => {
            const { pathData, color, width, brushStyle } = drawingPath;

            const drawingAnn = new DrawingAnnotation(
              page,
              pathData,
              color,
              width,
              brushStyle,
            );

            const points = pathData.match(/[ML]\s*([\d.]+)\s*([\d.]+)/g) || [];
            let minX = Infinity,
              minY = Infinity,
              maxX = -Infinity,
              maxY = -Infinity;

            points.forEach((p) => {
              const parts = p.match(/[\d.]+/g);
              if (parts && parts.length >= 2) {
                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
              }
            });

            const scaleX = page.viewport.width / page.drawingCanvas.width;
            const scaleY = page.viewport.height / page.drawingCanvas.height;

            const padding = 2;

            drawingAnn.x = minX * scaleX - padding;
            drawingAnn.y = minY * scaleY - padding;
            drawingAnn.width = (maxX - minX) * scaleX + padding * 2;
            drawingAnn.height = (maxY - minY) * scaleY + padding * 2;

            if (drawingAnn.width < 15) drawingAnn.width = 15;
            if (drawingAnn.height < 15) drawingAnn.height = 15;

            const element = drawingAnn.createElement();
            page.annotationLayer.appendChild(element);
            page.addAnnotation(drawingAnn);
          });
          if (page.annotations.length > 0) {
            selectAnnotation(page.annotations[page.annotations.length - 1]);
          }
        }

        currentTool = null;
        drawBtn.classList.remove("active");

        const ctx = page.drawingCanvas.getContext("2d");
        ctx.clearRect(
          0,
          0,
          page.drawingCanvas.width,
          page.drawingCanvas.height,
        );
        page.drawingCanvas.classList.remove("active");
        page.hasDrawing = false;
        page.currentDrawingPaths = [];

        pages.forEach((p) => {
          if (p.drawingCanvas) {
            p.drawingCanvas.classList.remove("active");
          }
        });
      });

      // Tool handlers
      addTextBtn.addEventListener("click", (e) => {
        setTool("text");
        if (e.target.closest(".tool-btn") === addTextBtn) {
          addAnnotationToCurrentPage("text");
        }
      });

      addImageBtn.addEventListener("click", () => {
        imageUpload.click();
      });

      imageUpload.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          setTool("image", event.target.result);
          addAnnotationToCurrentPage("image", event.target.result);
        };
        reader.readAsDataURL(file);
        imageUpload.value = "";
      });

      drawBtn.addEventListener("click", () => {
        if (selectedAnnotation) {
          selectedAnnotation.element.classList.remove("selected");
          selectedAnnotation = null;
        }
        setTool("draw");
      });

      addShapeBtn.addEventListener("click", (e) => {
        setTool("shape");
      });

      document.getElementById("applyShapeBtn").addEventListener("click", () => {
        addAnnotationToCurrentPage("shape");
      });

      function setTool(tool, data = null) {
        currentTool = tool;
        document
          .querySelectorAll(".tool-btn")
          .forEach((btn) => btn.classList.remove("active"));

        if (tool === "text") addTextBtn.classList.add("active");
        else if (tool === "draw") drawBtn.classList.add("active");
        else if (tool === "shape") addShapeBtn.classList.add("active");

        pages.forEach((page) => {
          if (tool === "draw") {
            page.drawingCanvas.classList.add("active");
          } else {
            page.drawingCanvas.classList.remove("active");
          }
        });

        if (selectedAnnotation) {
          selectedAnnotation.element.classList.remove("selected");
          selectedAnnotation = null;
        }
      }

      function addAnnotationToCurrentPage(type, data = null) {
        const page = pages[currentPageIndex];
        let annotation;

        if (type === "text") {
          annotation = new TextAnnotation(page, false);
          annotation.fontSize = parseInt(
            document.getElementById("fontSize").value,
          );
          annotation.fontFamily = document.getElementById("fontFamily").value;
          annotation.color = document.getElementById("textColor").value;
          annotation.fontWeight = document.getElementById("fontWeight").value;
          annotation.fontStyle = document.getElementById("fontStyle").value;
        } else if (type === "image") {
          annotation = new ImageAnnotation(page, data);
        } else if (type === "shape") {
          const shapeType = document.getElementById("shapeType").value;
          annotation = new ShapeAnnotation(page, shapeType);
          annotation.fillColor =
            document.getElementById("shapeFillColor").value;
          annotation.borderColor =
            document.getElementById("shapeBorderColor").value;
          annotation.borderWidth = parseInt(
            document.getElementById("shapeBorderWidth").value,
          );
        }

        if (annotation) {
          const centerX = page.viewport.width / 2 - annotation.width / 2;
          const centerY = page.viewport.height / 2 - annotation.height / 2;

          annotation.x = centerX;
          annotation.y = centerY;
          const element = annotation.createElement();
          page.annotationLayer.appendChild(element);
          page.addAnnotation(annotation);
          selectAnnotation(annotation);
        }
      }

      function selectAnnotation(annotation) {
        if (selectedAnnotation) {
          selectedAnnotation.element.classList.remove("selected");
        }
        selectedAnnotation = annotation;
        annotation.element.classList.add("selected");

        if (annotation.type === "text") {
          document.getElementById("fontSize").value = annotation.fontSize;
          document.getElementById("fontFamily").value = annotation.fontFamily;
          document.getElementById("textColor").value = annotation.color;
          document.getElementById("textColorHex").value = annotation.color;
          document.getElementById("fontWeight").value = annotation.fontWeight;
          document.getElementById("fontStyle").value = annotation.fontStyle;
        } else if (annotation.type === "shape") {
          document.getElementById("shapeType").value = annotation.shapeType;
          document.getElementById("shapeFillColor").value =
            annotation.fillColor;
          document.getElementById("shapeFillHex").value = annotation.fillColor;
          document.getElementById("shapeBorderColor").value =
            annotation.borderColor;
          document.getElementById("shapeBorderHex").value =
            annotation.borderColor;
          document.getElementById("shapeBorderWidth").value =
            annotation.borderWidth;
        }
      }

      // Property change handlers
      document.getElementById("fontSize").addEventListener("input", (e) => {
        if (selectedAnnotation && selectedAnnotation.type === "text") {
          selectedAnnotation.updateProperty(
            "fontSize",
            parseInt(e.target.value),
          );
        }
      });

      document.getElementById("fontFamily").addEventListener("change", (e) => {
        if (selectedAnnotation && selectedAnnotation.type === "text") {
          selectedAnnotation.updateProperty("fontFamily", e.target.value);
        }
      });

      document.getElementById("textColor").addEventListener("input", (e) => {
        document.getElementById("textColorHex").value = e.target.value;
        if (selectedAnnotation && selectedAnnotation.type === "text") {
          selectedAnnotation.updateProperty("color", e.target.value);
        }
      });

      document.getElementById("textColorHex").addEventListener("input", (e) => {
        const color = e.target.value;
        if (/^#[0-9A-F]{6}$/i.test(color)) {
          document.getElementById("textColor").value = color;
          if (selectedAnnotation && selectedAnnotation.type === "text") {
            selectedAnnotation.updateProperty("color", color);
          }
        }
      });

      document.getElementById("fontWeight").addEventListener("change", (e) => {
        if (selectedAnnotation && selectedAnnotation.type === "text") {
          selectedAnnotation.updateProperty("fontWeight", e.target.value);
        }
      });

      document.getElementById("fontStyle").addEventListener("change", (e) => {
        if (selectedAnnotation && selectedAnnotation.type === "text") {
          selectedAnnotation.updateProperty("fontStyle", e.target.value);
        }
      });

      document.getElementById("shapeType").addEventListener("change", (e) => {
        if (selectedAnnotation && selectedAnnotation.type === "shape") {
          selectedAnnotation.updateProperty("shapeType", e.target.value);
        }
      });

      document
        .getElementById("shapeFillColor")
        .addEventListener("input", (e) => {
          document.getElementById("shapeFillHex").value = e.target.value;
          if (selectedAnnotation && selectedAnnotation.type === "shape") {
            selectedAnnotation.updateProperty("fillColor", e.target.value);
          }
        });

      document.getElementById("shapeFillHex").addEventListener("input", (e) => {
        const color = e.target.value;
        if (/^#[0-9A-F]{6}$/i.test(color)) {
          document.getElementById("shapeFillColor").value = color;
          if (selectedAnnotation && selectedAnnotation.type === "shape") {
            selectedAnnotation.updateProperty("fillColor", color);
          }
        }
      });

      document
        .getElementById("shapeBorderColor")
        .addEventListener("input", (e) => {
          document.getElementById("shapeBorderHex").value = e.target.value;
          if (selectedAnnotation && selectedAnnotation.type === "shape") {
            selectedAnnotation.updateProperty("borderColor", e.target.value);
          }
        });

      document
        .getElementById("shapeBorderHex")
        .addEventListener("input", (e) => {
          const color = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(color)) {
            document.getElementById("shapeBorderColor").value = color;
            if (selectedAnnotation && selectedAnnotation.type === "shape") {
              selectedAnnotation.updateProperty("borderColor", color);
            }
          }
        });

      document
        .getElementById("shapeBorderWidth")
        .addEventListener("input", (e) => {
          if (selectedAnnotation && selectedAnnotation.type === "shape") {
            selectedAnnotation.updateProperty(
              "borderWidth",
              parseInt(e.target.value),
            );
          }
        });

      penColor.addEventListener("input", (e) => {
        document.getElementById("penColorHex").value = e.target.value;
      });

      document.getElementById("penColorHex").addEventListener("input", (e) => {
        const color = e.target.value;
        if (/^#[0-9A-F]{6}$/i.test(color)) {
          penColor.value = color;
        }
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging && selectedAnnotation) {
          const rect =
            selectedAnnotation.page.annotationLayer.getBoundingClientRect();
          const x = e.clientX - rect.left - dragStartX;
          const y = e.clientY - rect.top - dragStartY;
          selectedAnnotation.updatePosition(
            Math.max(0, Math.min(x, rect.width - selectedAnnotation.width)),
            Math.max(0, Math.min(y, rect.height - selectedAnnotation.height)),
          );
        } else if (isResizing && selectedAnnotation) {
          const rect =
            selectedAnnotation.page.annotationLayer.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          let newWidth = selectedAnnotation.width;
          let newHeight = selectedAnnotation.height;
          let newX = selectedAnnotation.x;
          let newY = selectedAnnotation.y;

          if (resizeHandle.includes("e")) {
            newWidth = mouseX - selectedAnnotation.x;
          }
          if (resizeHandle.includes("w")) {
            newWidth =
              selectedAnnotation.width + (selectedAnnotation.x - mouseX);
            newX = mouseX;
          }
          if (resizeHandle.includes("s")) {
            newHeight = mouseY - selectedAnnotation.y;
          }
          if (resizeHandle.includes("n")) {
            newHeight =
              selectedAnnotation.height + (selectedAnnotation.y - mouseY);
            newY = mouseY;
          }

          if (newWidth > 20 && newHeight > 20) {
            selectedAnnotation.updateSize(newWidth, newHeight);
            if (
              newX !== selectedAnnotation.x ||
              newY !== selectedAnnotation.y
            ) {
              selectedAnnotation.updatePosition(newX, newY);
            }
          }
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        isResizing = false;
        resizeHandle = null;
      });

      document.addEventListener(
        "touchmove",
        (e) => {
          if (!isDragging && !isResizing) return;

          e.preventDefault();
          const touch = e.touches[0];

          if (isDragging && selectedAnnotation) {
            const rect =
              selectedAnnotation.page.annotationLayer.getBoundingClientRect();
            const x = touch.clientX - rect.left - dragStartX;
            const y = touch.clientY - rect.top - dragStartY;
            selectedAnnotation.updatePosition(
              Math.max(0, Math.min(x, rect.width - selectedAnnotation.width)),
              Math.max(0, Math.min(y, rect.height - selectedAnnotation.height)),
            );
          } else if (isResizing && selectedAnnotation) {
            const rect =
              selectedAnnotation.page.annotationLayer.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            let newWidth = selectedAnnotation.width;
            let newHeight = selectedAnnotation.height;
            let newX = selectedAnnotation.x;
            let newY = selectedAnnotation.y;

            if (resizeHandle.includes("e")) {
              newWidth = touchX - selectedAnnotation.x;
            }
            if (resizeHandle.includes("w")) {
              newWidth =
                selectedAnnotation.width + (selectedAnnotation.x - touchX);
              newX = touchX;
            }
            if (resizeHandle.includes("s")) {
              newHeight = touchY - selectedAnnotation.y;
            }
            if (resizeHandle.includes("n")) {
              newHeight =
                selectedAnnotation.height + (selectedAnnotation.y - touchY);
              newY = touchY;
            }

            if (newWidth > 20 && newHeight > 20) {
              selectedAnnotation.updateSize(newWidth, newHeight);
              if (
                newX !== selectedAnnotation.x ||
                newY !== selectedAnnotation.y
              ) {
                selectedAnnotation.updatePosition(newX, newY);
              }
            }
          }
        },
        { passive: false },
      );

      document.addEventListener(
        "touchend",
        () => {
          isDragging = false;
          isResizing = false;
          resizeHandle = null;
        },
        { passive: false },
      );

      undoBtn.addEventListener("click", () => {
        const currentPage = pages[currentPageIndex];
        if (currentPage.annotations.length > 0) {
          const lastAnnotation =
            currentPage.annotations[currentPage.annotations.length - 1];
          lastAnnotation.delete();
          Toast.info("Last annotation removed");
        }
      });

      clearAllBtn.addEventListener("click", async () => {
        const confirmed = await CustomModal.confirm(
          "Clear all annotations on this page?",
          "Confirm Action",
        );
        if (confirmed) {
          const currentPage = pages[currentPageIndex];
          [...currentPage.annotations].forEach((ann) => ann.delete());
          const ctx = currentPage.drawingCanvas.getContext("2d");
          ctx.clearRect(
            0,
            0,
            currentPage.drawingCanvas.width,
            currentPage.drawingCanvas.height,
          );
          currentPage.hasDrawing = false;
          currentPage.currentDrawingPaths = [];
          selectedAnnotation = null;
          Toast.success("All annotations cleared");
        }
      });

      deleteFileBtn.addEventListener("click", async () => {
        const confirmed = await CustomModal.confirm(
          "Remove this PDF and start over? All your changes will be lost.",
          "Confirm Deletion",
          "danger",
        );
        if (confirmed) {
          pdfDoc = null;
          pdfFile = null;
          pages = [];
          currentPageIndex = 0;
          selectedAnnotation = null;
          isEditMode = false;

          pdfUpload.value = "";

          editorContainer.style.display = "none";
          uploadSection.style.display = "flex";

          canvasContainer.innerHTML = "";
          thumbnailContainer.innerHTML = "";

          currentFileName.textContent = "document.pdf";

          editPdfBtn.innerHTML =
            '<i class="fa fa-pen-to-square"></i> <span>Edit PDF</span>';
          editPdfBtn.disabled = false;
          editPdfBtn.classList.remove("active");

          currentTool = null;
          document
            .querySelectorAll(".tool-btn")
            .forEach((btn) => btn.classList.remove("active"));

          Toast.success("PDF removed successfully");
        }
      });

      document.addEventListener("click", (e) => {
        if (
          !e.target.closest(".annotation-item") &&
          !e.target.closest(".tool-btn") &&
          !e.target.closest(".ocr-text-block")
        ) {
          if (selectedAnnotation) {
            selectedAnnotation.element.classList.remove("selected");
            selectedAnnotation = null;
          }
        }
      });

      document.querySelectorAll(".properties-dropdown").forEach((dropdown) => {
        dropdown.addEventListener("click", (e) => {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
