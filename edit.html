<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF Editor | PDFMaster</title>
    <link
      href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      html,
      body {
        height: 100%;
        font-family: "DM Sans", sans-serif;
        background: #0f1117;
        color: #e2e8f0;
        overflow: hidden;
      }

      :root {
        --bg: #0f1117;
        --surface: #1a1d27;
        --surface2: #22263a;
        --border: #2d3148;
        --accent: #6366f1;
        --accent-h: #4f52d9;
        --danger: #f43f5e;
        --success: #10b981;
        --info: #38bdf8;
        --warn: #f59e0b;
        --text: #e2e8f0;
        --muted: #64748b;
        --sb: 96px;
        --fbar: 38px;
        --tbar: 52px;
      }

      /* ══ UPLOAD ══ */
      #uploadScreen {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
      }
      .upload-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        padding: 56px 44px;
        border: 2px dashed var(--border);
        border-radius: 24px;
        background: var(--surface);
        cursor: pointer;
        transition: all 0.22s;
        max-width: 420px;
        width: 90%;
        text-align: center;
      }
      .upload-card:hover {
        border-color: var(--accent);
        background: var(--surface2);
      }
      .upload-card .ico {
        width: 68px;
        height: 68px;
        border-radius: 16px;
        background: rgba(99, 102, 241, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        color: var(--accent);
      }
      .upload-card h2 {
        font-size: 21px;
        font-weight: 700;
      }
      .upload-card p {
        font-size: 13px;
        color: var(--muted);
        line-height: 1.55;
      }
      .upload-card .badge {
        font-size: 11px;
        background: rgba(99, 102, 241, 0.12);
        color: var(--accent);
        padding: 4px 12px;
        border-radius: 20px;
        font-weight: 600;
      }

      /* ══ EDITOR SHELL ══ */
      #editorScreen {
        display: none;
        flex-direction: column;
        height: 100vh;
        width: 100%;
      }
      #editorScreen.show {
        display: flex;
      }

      /* ══ FILE BAR ══ */
      .file-bar {
        height: var(--fbar);
        min-height: var(--fbar);
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 14px;
        flex-shrink: 0;
      }
      .file-bar .ficon {
        color: var(--danger);
        font-size: 15px;
        flex-shrink: 0;
      }
      .file-bar .fname {
        font-size: 13px;
        font-weight: 600;
        flex: 1;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .file-bar .xbtn {
        background: none;
        border: none;
        color: var(--muted);
        cursor: pointer;
        font-size: 15px;
        padding: 5px 7px;
        border-radius: 6px;
        transition: all 0.15s;
        flex-shrink: 0;
      }
      .file-bar .xbtn:hover {
        color: var(--danger);
        background: rgba(244, 63, 94, 0.12);
      }

      /* ══ TOOLBAR ══ */
      .toolbar {
        min-height: var(--tbar);
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 2px;
        padding: 0 8px;
        flex-shrink: 0;
        overflow-x: auto;
        overflow-y: visible;
        scrollbar-width: none;
        position: relative;
        z-index: 100;
        flex-wrap: nowrap;
      }
      .toolbar::-webkit-scrollbar {
        display: none;
      }

      .tbtn {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 6px 11px;
        border: 1.5px solid var(--border);
        border-radius: 7px;
        background: transparent;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        cursor: pointer;
        white-space: nowrap;
        font-family: inherit;
        transition: all 0.14s;
        flex-shrink: 0;
      }
      .tbtn i {
        font-size: 11px;
      }
      .tbtn:hover {
        background: var(--surface2);
        border-color: #3d4268;
        color: var(--text);
      }
      .tbtn.on {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }
      .tbtn.cta {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }
      .tbtn.cta:hover {
        background: var(--accent-h);
      }
      .tsep {
        width: 1px;
        height: 24px;
        background: var(--border);
        margin: 0 3px;
        flex-shrink: 0;
      }
      .tgap {
        flex: 1;
        min-width: 4px;
      }

      /* ══ PANEL HOST ══ */
      .panel-host {
        position: relative;
        z-index: 300;
        flex-shrink: 0;
      }
      .prop-panel {
        display: none;
        position: absolute;
        top: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 14px 48px rgba(0, 0, 0, 0.6);
        min-width: 300px;
        flex-direction: column;
        gap: 11px;
      }
      .prop-panel.open {
        display: flex;
      }

      .pp-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border);
      }
      .pp-header-left {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .pp-header-title {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
      }
      .pp-close {
        background: none;
        border: none;
        color: var(--muted);
        cursor: pointer;
        font-size: 13px;
        padding: 3px 6px;
        border-radius: 5px;
        transition: all 0.14s;
        line-height: 1;
        flex-shrink: 0;
      }
      .pp-close:hover {
        color: var(--danger);
        background: rgba(244, 63, 94, 0.12);
      }

      .pp-title {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border);
      }
      .pp-row {
        display: flex;
        flex-wrap: wrap;
        gap: 9px;
        align-items: flex-end;
      }
      .pp-field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .pp-field label {
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
      }
      .pp-field input[type="number"],
      .pp-field select {
        padding: 5px 8px;
        border: 1px solid var(--border);
        border-radius: 6px;
        font-size: 12px;
        background: var(--surface2);
        color: var(--text);
        min-width: 76px;
        font-family: inherit;
        outline: none;
      }
      .pp-field input[type="number"]:focus,
      .pp-field select:focus {
        border-color: var(--accent);
      }
      .pp-field input[type="color"] {
        width: 36px;
        height: 28px;
        border: 1px solid var(--border);
        border-radius: 5px;
        cursor: pointer;
        padding: 2px;
        background: var(--surface2);
      }
      .pp-footer {
        padding-top: 9px;
        border-top: 1px solid var(--border);
        display: flex;
        gap: 7px;
        flex-wrap: wrap;
        align-items: center;
      }
      .pp-btn {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 6px 13px;
        border: none;
        border-radius: 7px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        font-family: inherit;
        transition: background 0.14s;
      }
      .pp-btn.primary {
        background: var(--accent);
        color: #fff;
      }
      .pp-btn.primary:hover {
        background: var(--accent-h);
      }
      .pp-btn.success {
        background: var(--success);
        color: #fff;
      }
      .pp-btn.success:hover {
        background: #059669;
      }

      .edit-badge {
        font-size: 10px;
        background: rgba(248, 159, 0, 0.15);
        color: var(--warn);
        padding: 3px 9px;
        border-radius: 20px;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 4px;
      }
      .edit-badge.show {
        display: inline-flex;
      }

      .text-edit-badge {
        font-size: 10px;
        background: rgba(56, 189, 248, 0.15);
        color: var(--info);
        padding: 3px 9px;
        border-radius: 20px;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 4px;
      }
      .text-edit-badge.show {
        display: inline-flex;
      }

      .shape-edit-badge {
        font-size: 10px;
        background: rgba(99, 102, 241, 0.15);
        color: var(--accent);
        padding: 3px 9px;
        border-radius: 20px;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 4px;
      }
      .shape-edit-badge.show {
        display: inline-flex;
      }

      .image-edit-badge {
        font-size: 10px;
        background: rgba(16, 185, 129, 0.15);
        color: var(--success);
        padding: 3px 9px;
        border-radius: 20px;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 4px;
      }
      .image-edit-badge.show {
        display: inline-flex;
      }

      /* ══ EDITOR BODY ══ */
      .editor-body {
        display: flex;
        flex: 1;
        overflow: hidden;
        min-height: 0;
      }

      /* ══ SIDEBAR ══ */
      .sidebar {
        width: var(--sb);
        min-width: var(--sb);
        background: var(--surface);
        border-right: 1px solid var(--border);
        overflow-y: auto;
        overflow-x: hidden; /* FIX: prevent horizontal overflow */
        padding: 7px 5px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        scrollbar-width: thin;
        scrollbar-color: var(--border) transparent;
        flex-shrink: 0;
      }
      .sb-title {
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--muted);
        padding: 3px 2px 6px;
        border-bottom: 1px solid var(--border);
        text-align: center;
        margin-bottom: 2px;
        flex-shrink: 0;
      }
      .thumb {
        cursor: pointer;
        border-radius: 6px;
        border: 2px solid transparent;
        overflow: hidden;
        transition: border-color 0.2s;
        text-align: center;
        /* FIX: constrain width so canvas never overflows sidebar */
        width: 100%;
        max-width: 100%;
        flex-shrink: 0;
      }
      .thumb:hover {
        border-color: #3d4268;
      }
      .thumb.active {
        border-color: var(--accent);
      }
      .thumb canvas {
        display: block;
        width: 100%;
        height: auto;
        /* FIX: ensure canvas never stretches wider than container */
        max-width: 100%;
      }
      .thumb .pg {
        font-size: 10px;
        color: var(--muted);
        padding: 3px 0;
        font-weight: 600;
      }

      /* ══ CANVAS AREA ══ */
      .canvas-area {
        flex: 1;
        overflow: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 24px;
        gap: 24px;
        background: var(--bg);
        min-width: 0;
      }
      .page-block {
        position: relative;
        box-shadow: 0 8px 40px rgba(0, 0, 0, 0.55);
        border-radius: 3px;
        overflow: hidden;
        flex-shrink: 0;
      }
      .page-block canvas.pdf-bg {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }
      .page-block canvas.fab-layer {
        position: absolute;
        top: 0;
        left: 0;
      }

      /* ══ ANNOTATION BAR ══ */
      #annotBar {
        display: none;
        position: fixed;
        z-index: 1000;
        background: #1a1d27;
        border: 1px solid var(--border);
        border-radius: 10px;
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.6);
        padding: 5px 7px;
        gap: 4px;
        align-items: center;
      }
      #annotBar.show {
        display: flex;
      }
      .ab-btn {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: none;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        color: #fff;
        font-family: inherit;
        transition: opacity 0.14s;
      }
      .ab-btn:hover {
        opacity: 0.8;
      }
      .ab-btn.edit {
        background: var(--info);
      }
      .ab-btn.rot {
        background: var(--warn);
      }
      .ab-btn.copy {
        background: var(--success);
      }
      .ab-btn.del {
        background: var(--danger);
      }
      .ab-btn i {
        font-size: 10px;
      }
      .ab-sep {
        width: 1px;
        height: 18px;
        background: rgba(255, 255, 255, 0.12);
      }

      /* ══ LOADING OVERLAY ══ */
      #loadingOverlay {
        display: none;
        position: fixed;
        inset: 0;
        z-index: 4000;
        background: rgba(15, 17, 23, 0.82);
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 14px;
        backdrop-filter: blur(3px);
      }
      #loadingOverlay.show {
        display: flex;
      }
      .loading-spinner {
        width: 44px;
        height: 44px;
        border: 4px solid var(--border);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.7s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .loading-text {
        font-size: 13px;
        font-weight: 600;
        color: var(--muted);
      }
      .loading-progress {
        font-size: 11px;
        color: var(--muted);
        opacity: 0.7;
      }

      /* ══ CUSTOM MODAL ══ */
      #modalOverlay {
        display: none;
        position: fixed;
        inset: 0;
        z-index: 5000;
        background: rgba(0, 0, 0, 0.65);
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(3px);
      }
      #modalOverlay.show {
        display: flex;
      }
      .modal-box {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 28px 28px 22px;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.7);
        max-width: 380px;
        width: 90%;
        display: flex;
        flex-direction: column;
        gap: 16px;
        animation: mPop 0.22s ease;
      }
      @keyframes mPop {
        from {
          transform: scale(0.9);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal-icon {
        width: 48px;
        height: 48px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        flex-shrink: 0;
      }
      .modal-icon.warn {
        background: rgba(245, 158, 11, 0.15);
        color: var(--warn);
      }
      .modal-icon.info {
        background: rgba(56, 189, 248, 0.15);
        color: var(--info);
      }
      .modal-icon.danger {
        background: rgba(244, 63, 94, 0.15);
        color: var(--danger);
      }
      .modal-head {
        display: flex;
        align-items: flex-start;
        gap: 14px;
      }
      .modal-title {
        font-size: 16px;
        font-weight: 700;
        color: var(--text);
        margin-bottom: 4px;
      }
      .modal-msg {
        font-size: 13px;
        color: var(--muted);
        line-height: 1.55;
      }
      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        padding-top: 4px;
      }
      .modal-btn {
        padding: 8px 18px;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.14s;
      }
      .modal-btn.secondary {
        background: var(--surface2);
        color: var(--text);
        border: 1px solid var(--border);
      }
      .modal-btn.secondary:hover {
        border-color: #3d4268;
        background: #2a2f45;
      }
      .modal-btn.primary {
        background: var(--accent);
        color: #fff;
      }
      .modal-btn.primary:hover {
        background: var(--accent-h);
      }
      .modal-btn.danger {
        background: var(--danger);
        color: #fff;
      }
      .modal-btn.danger:hover {
        background: #d9304f;
      }

      /* ══ TOASTS ══ */
      #toastBox {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 6px;
        pointer-events: none;
      }
      .toast {
        background: var(--surface);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        padding: 9px 13px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        min-width: 190px;
        border-left: 3px solid var(--accent);
        animation: tin 0.24s ease;
      }
      .toast.s {
        border-left-color: var(--success);
      }
      .toast.e {
        border-left-color: var(--danger);
      }
      .toast.i {
        border-left-color: var(--info);
      }
      .toast i {
        font-size: 13px;
      }
      .toast.s i {
        color: var(--success);
      }
      .toast.e i {
        color: var(--danger);
      }
      .toast.i i {
        color: var(--info);
      }
      @keyframes tin {
        from {
          transform: translateX(110%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* ══ RESPONSIVE ══ */
      @media (max-width: 640px) {
        :root {
          --sb: 62px;
        }
        .tbtn span {
          display: none;
        }
        .tbtn {
          padding: 6px 8px;
        }
        .canvas-area {
          padding: 10px 6px;
        }
        .prop-panel {
          min-width: 240px;
          max-width: 304px;
        }
      }
      @media (max-width: 380px) {
        :root {
          --sb: 50px;
        }
        .sb-title {
          font-size: 8px;
        }
        .canvas-area {
          padding: 6px 3px;
        }
      }

      .hidden {
        display: none !important;
      }

      /* ══ SAVE RESULT SCREEN ══ */
      #saveScreen {
        display: none;
        flex-direction: column;
        height: 100vh;
        width: 100%;
        background: var(--bg);
      }
      #saveScreen.show {
        display: flex;
      }
      .save-topbar {
        height: var(--fbar);
        min-height: 52px;
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 14px;
        gap: 10px;
        flex-shrink: 0;
        flex-wrap: wrap;
      }
      .save-topbar-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
        flex: 1;
      }
      .save-fname {
        font-size: 13px;
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 260px;
      }
      .save-topbar-right {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-shrink: 0;
      }
      .sav-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 13px;
        border: 1.5px solid var(--border);
        border-radius: 7px;
        background: transparent;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        cursor: pointer;
        white-space: nowrap;
        font-family: inherit;
        transition: all 0.14s;
        flex-shrink: 0;
      }
      .sav-btn i {
        font-size: 11px;
      }
      .sav-btn:hover {
        background: var(--surface2);
        border-color: #3d4268;
        color: var(--text);
      }
      .sav-btn.download {
        background: var(--success);
        border-color: var(--success);
        color: #fff;
      }
      .sav-btn.download:hover {
        background: #059669;
        border-color: #059669;
      }
      .sav-btn.share {
        background: var(--info);
        border-color: var(--info);
        color: #fff;
      }
      .sav-btn.share:hover {
        background: #0ea5e9;
        border-color: #0ea5e9;
      }
      .sav-btn.reset {
        background: var(--warn);
        border-color: var(--warn);
        color: #fff;
      }
      .sav-btn.reset:hover {
        background: #d97706;
        border-color: #d97706;
      }
      .sav-btn.editpdf {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }
      .sav-btn.editpdf:hover {
        background: var(--accent-h);
        border-color: var(--accent-h);
      }
      .save-preview-wrap {
        flex: 1;
        overflow: hidden;
        display: flex;
        align-items: stretch;
        justify-content: center;
        padding: 0;
      }
      #savePreview {
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
      }

      /* ── Text align buttons ── */
      .align-btns {
        display: flex;
        gap: 2px;
      }
      .align-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border: 1px solid var(--border);
        border-radius: 5px;
        background: var(--surface2);
        color: var(--muted);
        cursor: pointer;
        font-size: 11px;
        transition: all 0.13s;
        padding: 0;
      }
      .align-btn:hover {
        background: var(--surface);
        color: var(--text);
        border-color: #3d4268;
      }
      .align-btn.on {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      @media (max-width: 640px) {
        .sav-btn span {
          display: none;
        }
        .sav-btn {
          padding: 6px 9px;
        }
        .save-fname {
          max-width: 140px;
        }
      }
    </style>
  </head>
  <body>
    <div id="toastBox"></div>

    <!-- Loading overlay (shown while PDF pages render) -->
    <div id="loadingOverlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading PDF…</div>
      <div class="loading-progress" id="loadingProgress"></div>
    </div>

    <!-- Custom modal -->
    <div id="modalOverlay">
      <div class="modal-box">
        <div class="modal-head">
          <div class="modal-icon" id="modalIcon">
            <i id="modalIconI" class="fa fa-circle-info"></i>
          </div>
          <div>
            <div class="modal-title" id="modalTitle">Notice</div>
            <div class="modal-msg" id="modalMsg"></div>
          </div>
        </div>
        <div class="modal-actions" id="modalActions"></div>
      </div>
    </div>

    <!-- Annotation bar -->
    <div id="annotBar">
      <button class="ab-btn edit" id="abEdit">
        <i class="fa fa-pen"></i> Edit
      </button>
      <div class="ab-sep"></div>
      <button class="ab-btn rot" id="abRot">
        <i class="fa fa-rotate-right"></i> Rotate
      </button>
      <div class="ab-sep"></div>
      <button class="ab-btn copy" id="abCopy">
        <i class="fa fa-copy"></i> Copy
      </button>
      <div class="ab-sep"></div>
      <button class="ab-btn del" id="abDel">
        <i class="fa fa-trash"></i> Delete
      </button>
    </div>

    <!-- Upload -->
    <div id="uploadScreen">
      <label class="upload-card" for="fileInput">
        <div class="ico"><i class="fa fa-file-pdf"></i></div>
        <h2>Upload PDF to Edit</h2>
        <p>Click to browse or drag &amp; drop<br />your PDF file here</p>
        <span class="badge">Editing happens entirely in your browser</span>
      </label>
      <input type="file" id="fileInput" accept=".pdf" class="hidden" />
    </div>

    <!-- Editor -->
    <div id="editorScreen">
      <div class="file-bar">
        <i class="fa fa-file-pdf ficon"></i>
        <span class="fname" id="fileName">document.pdf</span>
        <button class="xbtn" id="btnClose" title="Remove file">
          <i class="fa fa-xmark"></i>
        </button>
      </div>

      <div class="toolbar">
        <button class="tbtn" id="tbDraw">
          <i class="fa fa-pencil"></i><span>Draw</span>
        </button>
        <button class="tbtn" id="tbText">
          <i class="fa fa-font"></i><span>Add Text</span>
        </button>
        <button class="tbtn" id="tbShape">
          <i class="fa fa-shapes"></i><span>Shape</span>
        </button>
        <button class="tbtn" id="tbImage">
          <i class="fa fa-image"></i><span>Image</span>
        </button>
        <button class="tbtn" id="tbEditContent">
          <i class="fa fa-file-pen"></i><span>Edit Content</span>
        </button>
        <div class="tsep"></div>
        <button class="tbtn" id="tbUndo">
          <i class="fa fa-rotate-left"></i><span>Undo</span>
        </button>
        <button class="tbtn" id="tbClear">
          <i class="fa fa-eraser"></i><span>Clear</span>
        </button>
        <div class="tgap"></div>
        <button class="tbtn cta" id="tbSave">
          <i class="fa fa-floppy-disk"></i><span>Save PDF</span>
        </button>
      </div>

      <!-- Panel host -->
      <div class="panel-host" id="panelHost">
        <!-- Draw panel -->
        <div class="prop-panel" id="ppDraw">
          <div class="pp-header">
            <div class="pp-header-left">
              <span class="pp-header-title">Drawing Options</span>
              <span class="edit-badge" id="drawEditBadge"
                ><i class="fa fa-pen"></i> Editing selected</span
              >
            </div>
            <button class="pp-close" id="ppDrawClose" title="Close panel">
              <i class="fa fa-xmark"></i>
            </button>
          </div>
          <div class="pp-row">
            <div class="pp-field">
              <label>Color</label>
              <input type="color" id="dColor" value="#e63946" />
            </div>
            <div class="pp-field">
              <label>Width</label>
              <select id="dWidth">
                <option value="1">1 px</option>
                <option value="2" selected>2 px</option>
                <option value="3">3 px</option>
                <option value="5">5 px</option>
                <option value="8">8 px</option>
                <option value="12">12 px</option>
              </select>
            </div>
            <div class="pp-field">
              <label>Style</label>
              <select id="dStyle">
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
                <option value="dotted">Dotted</option>
              </select>
            </div>
            <div class="pp-field">
              <label>Opacity %</label>
              <input
                type="number"
                id="dOpacity"
                min="10"
                max="100"
                value="100"
                style="width: 68px"
              />
            </div>
          </div>
          <div class="pp-footer">
            <button class="pp-btn success" id="btnDrawAction">
              <i class="fa fa-check"></i>
              <span id="btnDrawActionLabel">Apply Drawing</span>
            </button>
          </div>
        </div>

        <!-- Text panel -->
        <div class="prop-panel" id="ppText">
          <div class="pp-header">
            <div class="pp-header-left">
              <span class="pp-header-title">Text Options</span>
              <span class="text-edit-badge" id="textEditBadge"
                ><i class="fa fa-pen"></i> Editing selected</span
              >
            </div>
            <button class="pp-close" id="ppTextClose" title="Close panel">
              <i class="fa fa-xmark"></i>
            </button>
          </div>
          <div class="pp-row">
            <div class="pp-field">
              <label>Color</label
              ><input type="color" id="tColor" value="#ffffff" />
            </div>
            <div class="pp-field">
              <label>Size</label
              ><input
                type="number"
                id="tSize"
                min="8"
                max="96"
                value="20"
                style="width: 66px"
              />
            </div>
            <div class="pp-field">
              <label>Font</label>
              <select id="tFont">
                <option>Arial</option>
                <option>Georgia</option>
                <option>Courier New</option>
                <option>Times New Roman</option>
                <option>Verdana</option>
                <option>Helvetica</option>
              </select>
            </div>
            <div class="pp-field">
              <label>Weight</label>
              <select id="tWeight">
                <option value="normal">Normal</option>
                <option value="bold">Bold</option>
              </select>
            </div>
            <div class="pp-field">
              <label>Align</label>
              <div class="align-btns" id="tAlignGroup">
                <button
                  type="button"
                  class="align-btn on"
                  data-align="left"
                  title="Left"
                >
                  <i class="fa fa-align-left"></i>
                </button>
                <button
                  type="button"
                  class="align-btn"
                  data-align="center"
                  title="Center"
                >
                  <i class="fa fa-align-center"></i>
                </button>
                <button
                  type="button"
                  class="align-btn"
                  data-align="right"
                  title="Right"
                >
                  <i class="fa fa-align-right"></i>
                </button>
              </div>
            </div>
          </div>
          <div class="pp-footer">
            <button
              class="pp-btn primary"
              id="btnAddText"
              style="display: inline-flex"
            >
              <i class="fa fa-plus"></i> Add Text to Page
            </button>
            <button
              class="pp-btn success"
              id="btnDoneEditText"
              style="display: none"
            >
              <i class="fa fa-check"></i> Done Editing
            </button>
          </div>
        </div>

        <!-- Shape panel -->
        <div class="prop-panel" id="ppShape">
          <div class="pp-header">
            <div class="pp-header-left">
              <span class="pp-header-title">Shape Options</span>
              <span class="shape-edit-badge" id="shapeEditBadge"
                ><i class="fa fa-pen"></i> Editing selected</span
              >
            </div>
            <button class="pp-close" id="ppShapeClose" title="Close panel">
              <i class="fa fa-xmark"></i>
            </button>
          </div>
          <div class="pp-row">
            <div class="pp-field">
              <label>Type</label>
              <select id="sType">
                <option value="rect">Rectangle</option>
                <option value="circle">Circle</option>
                <option value="triangle">Triangle</option>
                <option value="line">Line</option>
              </select>
            </div>
            <div class="pp-field">
              <label>Fill</label
              ><input type="color" id="sFill" value="#6366f1" />
            </div>
            <div class="pp-field">
              <label>Stroke</label
              ><input type="color" id="sStroke" value="#312e81" />
            </div>
            <div class="pp-field">
              <label>Stroke W</label
              ><input
                type="number"
                id="sStrokeW"
                min="0"
                max="20"
                value="2"
                style="width: 62px"
              />
            </div>
          </div>
          <div class="pp-footer">
            <button
              class="pp-btn primary"
              id="btnAddShape"
              style="display: inline-flex"
            >
              <i class="fa fa-plus"></i> Add Shape to Page
            </button>
            <button
              class="pp-btn success"
              id="btnDoneEditShape"
              style="display: none"
            >
              <i class="fa fa-check"></i> Done Editing
            </button>
          </div>
        </div>

        <!-- Image panel -->
        <div class="prop-panel" id="ppImage">
          <div class="pp-header">
            <div class="pp-header-left">
              <span class="pp-header-title">Image Options</span>
              <span class="image-edit-badge" id="imageEditBadge"
                ><i class="fa fa-pen"></i> Editing selected</span
              >
            </div>
            <button class="pp-close" id="ppImageClose" title="Close panel">
              <i class="fa fa-xmark"></i>
            </button>
          </div>
          <div class="pp-row">
            <div class="pp-field">
              <label>Opacity %</label
              ><input
                type="number"
                id="iOpacity"
                min="10"
                max="100"
                value="100"
                style="width: 72px"
              />
            </div>
            <div class="pp-field">
              <label>Corner Radius</label
              ><input
                type="number"
                id="iRadius"
                min="0"
                max="200"
                value="0"
                style="width: 80px"
              />
            </div>
          </div>
          <div class="pp-footer">
            <button class="pp-btn success" id="btnDoneEditImage">
              <i class="fa fa-check"></i> Done Editing
            </button>
          </div>
        </div>
      </div>
      <!-- /panel-host -->

      <div class="editor-body">
        <div class="sidebar" id="sidebar">
          <div class="sb-title">Pages</div>
        </div>
        <div class="canvas-area" id="canvasArea"></div>
      </div>
    </div>

    <input type="file" id="imgInput" accept="image/*" class="hidden" />

    <!-- Save Result Screen -->
    <div id="saveScreen">
      <div class="save-topbar">
        <div class="save-topbar-left">
          <i
            class="fa fa-file-pdf"
            style="color: var(--danger); font-size: 15px"
          ></i>
          <span class="save-fname" id="saveFname">edited_document.pdf</span>
        </div>
        <div class="save-topbar-right">
          <button class="sav-btn download" id="savDownload">
            <i class="fa fa-download"></i><span>Download</span>
          </button>
          <button class="sav-btn share" id="savShare">
            <i class="fa fa-share-nodes"></i><span>Share</span>
          </button>
          <button class="sav-btn reset" id="savReset">
            <i class="fa fa-rotate-left"></i><span>Reset</span>
          </button>
          <div class="tsep" style="height: 22px"></div>
          <button class="sav-btn editpdf" id="savEditPdf">
            <i class="fa fa-pen-to-square"></i><span>Edit PDF</span>
          </button>
        </div>
      </div>
      <div class="save-preview-wrap">
        <iframe id="savePreview" title="PDF Preview"></iframe>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      const API = `${BACKEND_BASE_URL}`;
      let pdfDoc = null,
        pdfFile = null;
      let pages = [];
      let curIdx = 0;
      let curTool = "draw";

      let editingPath = null,
        editingPathFC = null;
      let editingText = null,
        editingTextFC = null;
      let editingShape = null,
        editingShapeFC = null;
      let editingImage = null,
        editingImageFC = null;

      /* ═══════════════════════════════════════════════════════
         HELPERS — wait for one animation frame (layout flush)
      ═══════════════════════════════════════════════════════ */
      const nextFrame = () => new Promise((r) => requestAnimationFrame(r));

      /** Read the --sb CSS variable as a pixel number reliably */
      function getSidebarInnerWidth() {
        const sbEl = document.getElementById("sidebar");
        // offsetWidth is available after first layout; fall back to CSS var
        const w =
          sbEl.offsetWidth ||
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue("--sb"),
          ) ||
          96;
        return Math.max(w - 12, 40); // subtract padding, minimum 40
      }

      /* ═══════════════════════════════════════════════════════
         CUSTOM MODAL
      ═══════════════════════════════════════════════════════ */
      function showModal({
        title = "Notice",
        msg = "",
        type = "info",
        buttons,
      }) {
        return new Promise((resolve) => {
          const iconMap = {
            info: { cls: "info", ic: "fa-circle-info" },
            warn: { cls: "warn", ic: "fa-triangle-exclamation" },
            danger: { cls: "danger", ic: "fa-circle-exclamation" },
          };
          const im = iconMap[type] || iconMap.info;
          document.getElementById("modalIcon").className =
            `modal-icon ${im.cls}`;
          document.getElementById("modalIconI").className = `fa ${im.ic}`;
          document.getElementById("modalTitle").textContent = title;
          document.getElementById("modalMsg").textContent = msg;
          const actions = document.getElementById("modalActions");
          actions.innerHTML = "";
          buttons.forEach((b) => {
            const btn = document.createElement("button");
            btn.className = `modal-btn ${b.cls || "secondary"}`;
            btn.textContent = b.label;
            btn.onclick = () => {
              document.getElementById("modalOverlay").classList.remove("show");
              resolve(b.value);
            };
            actions.appendChild(btn);
          });
          document.getElementById("modalOverlay").classList.add("show");
        });
      }
      const mAlert = (msg, title = "Notice") =>
        showModal({
          title,
          msg,
          type: "info",
          buttons: [{ label: "OK", cls: "primary", value: true }],
        });
      const mConfirm = (msg, title = "Confirm", danger = false) =>
        showModal({
          title,
          msg,
          type: danger ? "danger" : "warn",
          buttons: [
            { label: "Cancel", cls: "secondary", value: false },
            {
              label: "Confirm",
              cls: danger ? "danger" : "primary",
              value: true,
            },
          ],
        });

      /* ═══════════════════════════════════════════════════════
         TOAST
      ═══════════════════════════════════════════════════════ */
      const TICONS = {
        s: "fa-check-circle",
        e: "fa-exclamation-circle",
        i: "fa-info-circle",
      };
      function toast(msg, type = "i") {
        const el = document.createElement("div");
        el.className = `toast ${type}`;
        el.innerHTML = `<i class="fa ${TICONS[type] || TICONS.i}"></i><span>${msg}</span>`;
        document.getElementById("toastBox").appendChild(el);
        setTimeout(() => {
          el.style.transition = "opacity .3s";
          el.style.opacity = "0";
          setTimeout(() => el.remove(), 320);
        }, 2800);
      }

      /* ═══════════════════════════════════════════════════════
         LOADING OVERLAY
      ═══════════════════════════════════════════════════════ */
      function showLoading(text = "Loading PDF…", progress = "") {
        document.querySelector("#loadingOverlay .loading-text").textContent =
          text;
        document.getElementById("loadingProgress").textContent = progress;
        document.getElementById("loadingOverlay").classList.add("show");
      }
      function updateLoadingProgress(text) {
        document.getElementById("loadingProgress").textContent = text;
      }
      function hideLoading() {
        document.getElementById("loadingOverlay").classList.remove("show");
      }

      /* ═══════════════════════════════════════════════════════
         UPLOAD
      ═══════════════════════════════════════════════════════ */
      document
        .getElementById("fileInput")
        .addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          pdfFile = file;
          document.getElementById("fileName").textContent = file.name;
          await loadPDF(file);
        });

      async function loadPDF(file) {
        showLoading("Parsing PDF…", "");
        await nextFrame(); // let overlay paint before heavy work

        const buf = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: buf }).promise;
        pages = [];

        // ── FIX 1: Show the editor shell and flush layout BEFORE
        //           building any page. This ensures sidebar/canvas
        //           dimensions are non-zero when we read them.
        document.getElementById("uploadScreen").style.display = "none";
        document.getElementById("editorScreen").classList.add("show");
        document.getElementById("sidebar").innerHTML =
          '<div class="sb-title">Pages</div>';
        document.getElementById("canvasArea").innerHTML = "";

        // Wait two frames so the browser completes flex layout
        await nextFrame();
        await nextFrame();

        const total = pdfDoc.numPages;
        for (let i = 1; i <= total; i++) {
          updateLoadingProgress(`Page ${i} of ${total}`);
          await buildPage(i);
        }

        curTool = "none";
        switchPage(0);
        hideLoading();
        toast(`PDF loaded — ${total} page(s)`, "s");
      }

      /* ═══════════════════════════════════════════════════════
         BUILD PAGE
      ═══════════════════════════════════════════════════════ */
      async function buildPage(pageNum) {
        const pdfPage = await pdfDoc.getPage(pageNum);
        const base = pdfPage.getViewport({ scale: 1 });

        const area = document.getElementById("canvasArea");
        // ── FIX 2: Use offsetWidth (post-layout) with safe fallback
        const areaW =
          area.offsetWidth ||
          Math.max(window.innerWidth - getSidebarInnerWidth() - 20, 300);
        const areaH =
          area.offsetHeight || Math.max(window.innerHeight - 160, 200);

        const pad = 48;
        const maxW = Math.max(areaW - pad, 300);
        const maxH = Math.max(areaH - pad, 200);

        let sc = maxW / base.width;
        if (base.height * sc > maxH) sc = maxH / base.height;
        sc = Math.max(sc, Math.min(1.5, maxW / base.width));

        const vp = pdfPage.getViewport({ scale: sc });
        const W = Math.round(vp.width);
        const H = Math.round(vp.height);

        const block = document.createElement("div");
        block.className = "page-block";
        block.style.cssText = `width:${W}px;height:${H}px;`;

        const pdfCvs = document.createElement("canvas");
        pdfCvs.className = "pdf-bg";
        pdfCvs.width = W;
        pdfCvs.height = H;
        pdfCvs.style.cssText = `width:${W}px;height:${H}px;`;
        await pdfPage.render({
          canvasContext: pdfCvs.getContext("2d"),
          viewport: vp,
        }).promise;

        const fabEl = document.createElement("canvas");
        fabEl.className = "fab-layer";
        fabEl.id = "fc-" + pageNum;
        fabEl.width = W;
        fabEl.height = H;
        fabEl.style.cssText = `width:${W}px;height:${H}px;`;

        block.appendChild(pdfCvs);
        block.appendChild(fabEl);
        document.getElementById("canvasArea").appendChild(block);

        const fc = new fabric.Canvas("fc-" + pageNum, {
          width: W,
          height: H,
          selection: true,
          preserveObjectStacking: true,
        });
        fc.setBackgroundColor("rgba(0,0,0,0)", fc.renderAll.bind(fc));

        fc.on("selection:created", () => onSelect(fc));
        fc.on("selection:updated", () => onSelect(fc));
        fc.on("selection:cleared", () => {
          hideAnnotBar();
          stopPathEdit();
          stopTextEdit();
          stopShapeEdit();
          stopImageEdit();
        });
        fc.on("object:moving", () => posAnnotBar(fc));
        fc.on("object:scaling", () => posAnnotBar(fc));
        fc.on("object:rotating", () => posAnnotBar(fc));

        // ── FIX 3: Thumbnail — use getSidebarInnerWidth() which reads
        //           offsetWidth AFTER the layout flush above.
        const sbInner = getSidebarInnerWidth();
        // Scale so the thumbnail fits the sidebar width exactly
        const thSc = sbInner / base.width;
        const thVp = pdfPage.getViewport({ scale: thSc });
        const thW = Math.max(Math.round(thVp.width), 1);
        const thH = Math.max(Math.round(thVp.height), 1);

        const thC = document.createElement("canvas");
        thC.width = thW;
        thC.height = thH;
        // CSS: fill sidebar width, height scales naturally
        thC.style.width = "100%";
        thC.style.height = "auto";
        thC.style.display = "block";
        await pdfPage.render({
          canvasContext: thC.getContext("2d"),
          viewport: thVp,
        }).promise;

        const thItem = document.createElement("div");
        thItem.className = "thumb";
        thItem.dataset.idx = pages.length;
        const pg = document.createElement("div");
        pg.className = "pg";
        pg.textContent = "Page " + pageNum;
        thItem.appendChild(thC);
        thItem.appendChild(pg);
        thItem.addEventListener("click", () => switchPage(+thItem.dataset.idx));
        document.getElementById("sidebar").appendChild(thItem);

        pages.push({ block, pdfCvs, fabricCanvas: fc, scale: sc, pageNum });
      }

      /* ═══════════════════════════════════════════════════════
         PAGE SWITCHING
      ═══════════════════════════════════════════════════════ */
      function switchPage(idx) {
        hideAnnotBar();
        stopPathEdit();
        stopTextEdit();
        stopShapeEdit();
        stopImageEdit();
        curIdx = idx;
        pages.forEach(
          (p, i) => (p.block.style.display = i === idx ? "block" : "none"),
        );
        document
          .querySelectorAll(".thumb")
          .forEach((t, i) => t.classList.toggle("active", i === idx));
        const th = document.querySelectorAll(".thumb")[idx];
        if (th) th.scrollIntoView({ block: "nearest", behavior: "smooth" });
        applyTool(getFC());
      }

      const getFC = () => pages[curIdx]?.fabricCanvas;

      /* ═══════════════════════════════════════════════════════
         ANNOTATION BAR
      ═══════════════════════════════════════════════════════ */
      const annotBar = document.getElementById("annotBar");

      function onSelect(fc) {
        const obj = fc.getActiveObject();
        if (editingPath && obj !== editingPath) stopPathEdit();
        if (editingText && obj !== editingText) stopTextEdit();
        if (editingShape && obj !== editingShape) stopShapeEdit();
        if (editingImage && obj !== editingImage) stopImageEdit();
        showAnnotBar(fc);
      }

      function showAnnotBar(fc) {
        if (!fc.getActiveObject()) {
          hideAnnotBar();
          return;
        }
        annotBar.classList.add("show");
        posAnnotBar(fc);
      }
      function hideAnnotBar() {
        annotBar.classList.remove("show");
      }

      function posAnnotBar(fc) {
        const obj = (fc || getFC())?.getActiveObject?.();
        if (!obj) return;
        const block = pages[curIdx]?.block;
        if (!block) return;
        const br = block.getBoundingClientRect();
        const ob = obj.getBoundingRect(true, true);
        let x = br.left + ob.left + ob.width / 2 - annotBar.offsetWidth / 2;
        let y = br.top + ob.top - annotBar.offsetHeight - 10;
        x = Math.max(
          6,
          Math.min(x, window.innerWidth - annotBar.offsetWidth - 6),
        );
        y = Math.max(
          6,
          Math.min(y, window.innerHeight - annotBar.offsetHeight - 6),
        );
        annotBar.style.left = x + "px";
        annotBar.style.top = y + "px";
      }

      document.getElementById("abEdit").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const obj = fc.getActiveObject();
        if (!obj) return;
        if (obj.type === "i-text" || obj.type === "text")
          startTextEdit(obj, fc);
        else if (["rect", "circle", "triangle", "line"].includes(obj.type))
          startShapeEdit(obj, fc);
        else if (obj.type === "path") startPathEdit(obj, fc);
        else if (obj.type === "image") startImageEdit(obj, fc);
        else toast("Use handles to resize & rotate", "i");
      });

      document.getElementById("abRot").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const obj = fc.getActiveObject();
        if (!obj) return;
        obj.rotate((obj.angle || 0) + 15);
        fc.requestRenderAll();
        posAnnotBar(fc);
        toast("Rotated +15°", "i");
      });

      document.getElementById("abCopy").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const obj = fc.getActiveObject();
        if (!obj) return;
        obj.clone((cl) => {
          cl.set({ left: obj.left + 22, top: obj.top + 22 });
          fc.add(cl);
          fc.setActiveObject(cl);
          fc.renderAll();
          showAnnotBar(fc);
          toast("Copied!", "s");
        });
      });

      document.getElementById("abDel").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        stopPathEdit();
        stopTextEdit();
        stopShapeEdit();
        stopImageEdit();
        fc.getActiveObjects().forEach((o) => fc.remove(o));
        fc.discardActiveObject();
        fc.renderAll();
        hideAnnotBar();
        toast("Deleted", "i");
      });

      /* ═══════════════════════════════════════════════════════
         PATH EDIT
      ═══════════════════════════════════════════════════════ */
      function startPathEdit(pathObj, fc) {
        editingPath = pathObj;
        editingPathFC = fc;
        document.getElementById("dColor").value = pathObj.stroke || "#e63946";
        const curW = pathObj.strokeWidth || 2;
        const opts = [1, 2, 3, 5, 8, 12];
        document.getElementById("dWidth").value = opts.reduce((p, c) =>
          Math.abs(c - curW) < Math.abs(p - curW) ? c : p,
        );
        document.getElementById("dOpacity").value = Math.round(
          (pathObj.opacity || 1) * 100,
        );
        const da = pathObj.strokeDashArray;
        document.getElementById("dStyle").value =
          !da || !da.length ? "solid" : da[1] <= 5 ? "dotted" : "dashed";
        document.getElementById("drawEditBadge").classList.add("show");
        document.getElementById("btnDrawActionLabel").textContent =
          "Done Editing";
        document.getElementById("btnDrawAction").className = "pp-btn primary";
        openPanel("ppDraw");
        toast("Editing selected drawing — adjust controls above", "i");
      }

      function stopPathEdit() {
        if (!editingPath) return;
        editingPath = null;
        editingPathFC = null;
        document.getElementById("drawEditBadge").classList.remove("show");
        document.getElementById("btnDrawActionLabel").textContent =
          "Apply Drawing";
        document.getElementById("btnDrawAction").className = "pp-btn success";
      }

      function syncDrawControls() {
        const color = document.getElementById("dColor").value;
        const width = parseInt(document.getElementById("dWidth").value);
        const opacity =
          parseInt(document.getElementById("dOpacity").value) / 100;
        const style = document.getElementById("dStyle").value;
        const dashArr =
          style === "dashed" ? [10, 6] : style === "dotted" ? [2, 5] : [];
        if (editingPath && editingPathFC) {
          editingPath.set({
            stroke: color,
            strokeWidth: width,
            opacity,
            strokeDashArray: dashArr,
          });
          editingPathFC.renderAll();
        } else {
          syncBrush();
        }
      }
      ["dColor", "dWidth", "dStyle", "dOpacity"].forEach((id) => {
        document.getElementById(id).addEventListener("input", syncDrawControls);
        document
          .getElementById(id)
          .addEventListener("change", syncDrawControls);
      });

      document.getElementById("btnDrawAction").addEventListener("click", () => {
        if (editingPath) {
          stopPathEdit();
          closePanel("ppDraw");
          setTool("draw");
          openPanel("ppDraw");
          showAnnotBar(getFC());
          toast("Drawing updated", "s");
        } else {
          setTool("none");
          closePanel("ppDraw");
          toast("Drawing applied — click any annotation to select it", "s");
        }
      });

      /* ═══════════════════════════════════════════════════════
         TEXT EDIT
      ═══════════════════════════════════════════════════════ */
      function startTextEdit(textObj, fc) {
        editingText = textObj;
        editingTextFC = fc;
        document.getElementById("tColor").value = textObj.fill || "#ffffff";
        document.getElementById("tSize").value = Math.round(
          textObj.fontSize || 20,
        );
        document.getElementById("tFont").value = textObj.fontFamily || "Arial";
        document.getElementById("tWeight").value =
          textObj.fontWeight || "normal";
        const align = textObj.textAlign || "left";
        document
          .querySelectorAll("#tAlignGroup .align-btn")
          .forEach((b) => b.classList.toggle("on", b.dataset.align === align));
        document.getElementById("textEditBadge").classList.add("show");
        document.getElementById("btnAddText").style.display = "none";
        document.getElementById("btnDoneEditText").style.display =
          "inline-flex";
        openPanel("ppText");
        toast("Editing selected text — adjust controls above", "i");
      }

      function stopTextEdit() {
        if (!editingText) return;
        editingText = null;
        editingTextFC = null;
        document.getElementById("textEditBadge").classList.remove("show");
        document.getElementById("btnAddText").style.display = "inline-flex";
        document.getElementById("btnDoneEditText").style.display = "none";
      }

      function getTextAlign() {
        const on = document.querySelector("#tAlignGroup .align-btn.on");
        return on ? on.dataset.align : "left";
      }

      function syncTextControls() {
        const color = document.getElementById("tColor").value;
        const size = parseInt(document.getElementById("tSize").value);
        const family = document.getElementById("tFont").value;
        const weight = document.getElementById("tWeight").value;
        const align = getTextAlign();
        if (editingText && editingTextFC) {
          editingText.set({
            fill: color,
            fontSize: size,
            fontFamily: family,
            fontWeight: weight,
            textAlign: align,
          });
          editingTextFC.renderAll();
        }
      }
      ["tColor", "tSize", "tFont", "tWeight"].forEach((id) => {
        document.getElementById(id).addEventListener("input", syncTextControls);
        document
          .getElementById(id)
          .addEventListener("change", syncTextControls);
      });
      document.querySelectorAll("#tAlignGroup .align-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll("#tAlignGroup .align-btn")
            .forEach((b) => b.classList.remove("on"));
          btn.classList.add("on");
          syncTextControls();
        });
      });

      document
        .getElementById("btnDoneEditText")
        .addEventListener("click", () => {
          stopTextEdit();
          closePanel("ppText");
          showAnnotBar(getFC());
          toast("Text updated", "s");
        });

      /* ═══════════════════════════════════════════════════════
         SHAPE EDIT
      ═══════════════════════════════════════════════════════ */
      function startShapeEdit(shapeObj, fc) {
        editingShape = shapeObj;
        editingShapeFC = fc;
        document.getElementById("sFill").value = shapeObj.fill || "#6366f1";
        document.getElementById("sStroke").value = shapeObj.stroke || "#312e81";
        document.getElementById("sStrokeW").value = shapeObj.strokeWidth || 2;
        const typeMap = {
          rect: "rect",
          circle: "circle",
          triangle: "triangle",
          line: "line",
        };
        document.getElementById("sType").value =
          typeMap[shapeObj.type] || "rect";
        document.getElementById("sType").disabled = true;
        document.getElementById("shapeEditBadge").classList.add("show");
        document.getElementById("btnAddShape").style.display = "none";
        document.getElementById("btnDoneEditShape").style.display =
          "inline-flex";
        openPanel("ppShape");
        toast("Editing selected shape — adjust controls above", "i");
      }

      function stopShapeEdit() {
        if (!editingShape) return;
        editingShape = null;
        editingShapeFC = null;
        document.getElementById("shapeEditBadge").classList.remove("show");
        document.getElementById("btnAddShape").style.display = "inline-flex";
        document.getElementById("btnDoneEditShape").style.display = "none";
        document.getElementById("sType").disabled = false;
      }

      function syncShapeControls() {
        if (editingShape && editingShapeFC) {
          editingShape.set({
            fill: document.getElementById("sFill").value,
            stroke: document.getElementById("sStroke").value,
            strokeWidth: +document.getElementById("sStrokeW").value || 1,
          });
          editingShapeFC.renderAll();
        }
      }
      ["sFill", "sStroke", "sStrokeW"].forEach((id) => {
        document
          .getElementById(id)
          .addEventListener("input", syncShapeControls);
        document
          .getElementById(id)
          .addEventListener("change", syncShapeControls);
      });

      document
        .getElementById("btnDoneEditShape")
        .addEventListener("click", () => {
          stopShapeEdit();
          closePanel("ppShape");
          showAnnotBar(getFC());
          toast("Shape updated", "s");
        });

      /* ═══════════════════════════════════════════════════════
         IMAGE EDIT
      ═══════════════════════════════════════════════════════ */
      function startImageEdit(imgObj, fc) {
        editingImage = imgObj;
        editingImageFC = fc;
        document.getElementById("iOpacity").value = Math.round(
          (imgObj.opacity || 1) * 100,
        );
        document.getElementById("iRadius").value = imgObj._cornerRadius || 0;
        document.getElementById("imageEditBadge").classList.add("show");
        openPanel("ppImage");
        toast("Editing image — adjust opacity & corner radius above", "i");
      }

      function stopImageEdit() {
        if (!editingImage) return;
        editingImage = null;
        editingImageFC = null;
        document.getElementById("imageEditBadge").classList.remove("show");
      }

      function applyImageRadius(imgObj, fc, radius) {
        imgObj._cornerRadius = radius;
        if (radius <= 0) {
          imgObj.set("clipPath", null);
        } else {
          const w = imgObj.width || imgObj.getScaledWidth();
          const h = imgObj.height || imgObj.getScaledHeight();
          const r = Math.min(radius, w / 2, h / 2);
          imgObj.set(
            "clipPath",
            new fabric.Rect({
              width: w,
              height: h,
              rx: r,
              ry: r,
              originX: "center",
              originY: "center",
              absolutePositioned: false,
            }),
          );
        }
        fc.requestRenderAll();
      }

      function syncImageControls() {
        if (!editingImage || !editingImageFC) return;
        const opacity =
          parseInt(document.getElementById("iOpacity").value) / 100;
        const radius = parseInt(document.getElementById("iRadius").value) || 0;
        editingImage.set({ opacity: Math.max(0.1, Math.min(1, opacity)) });
        applyImageRadius(editingImage, editingImageFC, radius);
      }
      ["iOpacity", "iRadius"].forEach((id) => {
        document
          .getElementById(id)
          .addEventListener("input", syncImageControls);
        document
          .getElementById(id)
          .addEventListener("change", syncImageControls);
      });

      document
        .getElementById("btnDoneEditImage")
        .addEventListener("click", () => {
          stopImageEdit();
          closePanel("ppImage");
          showAnnotBar(getFC());
          toast("Image updated", "s");
        });

      /* ═══════════════════════════════════════════════════════
         TOOL MANAGEMENT
      ═══════════════════════════════════════════════════════ */
      const TOOL_IDS = {
        draw: "tbDraw",
        text: "tbText",
        shape: "tbShape",
        image: "tbImage",
      };

      function setTool(name) {
        if (name !== "draw") stopPathEdit();
        if (name !== "text") stopTextEdit();
        if (name !== "shape" && name !== "none") stopShapeEdit();
        if (name !== "image" && name !== "none") stopImageEdit();
        curTool = name;
        Object.entries(TOOL_IDS).forEach(([t, id]) =>
          document.getElementById(id).classList.toggle("on", t === name),
        );
        applyTool(getFC());
      }

      function applyTool(fc) {
        if (!fc) return;
        fc.isDrawingMode = curTool === "draw";
        if (curTool === "draw") {
          const b = new fabric.PencilBrush(fc);
          b.color = document.getElementById("dColor").value;
          b.width = parseInt(document.getElementById("dWidth").value);
          fc.freeDrawingBrush = b;
          fc.off("path:created");
          fc.on("path:created", (e) => {
            const s = document.getElementById("dStyle").value;
            const o = parseInt(document.getElementById("dOpacity").value) / 100;
            if (s === "dashed") e.path.set({ strokeDashArray: [10, 6] });
            if (s === "dotted") e.path.set({ strokeDashArray: [2, 5] });
            e.path.set({ opacity: o });
            fc.renderAll();
          });
        } else {
          fc.off("path:created");
        }
      }

      function syncBrush() {
        const fc = getFC();
        if (!fc?.freeDrawingBrush) return;
        fc.freeDrawingBrush.color = document.getElementById("dColor").value;
        fc.freeDrawingBrush.width = parseInt(
          document.getElementById("dWidth").value,
        );
      }

      /* ── Panel helpers ── */
      function openPanel(id) {
        const btnMap = {
          ppDraw: "tbDraw",
          ppText: "tbText",
          ppShape: "tbShape",
          ppImage: "tbImage",
        };
        const host = document.getElementById("panelHost");
        const panel = document.getElementById(id);
        document.querySelectorAll(".prop-panel").forEach((p) => {
          if (p.id !== id) p.classList.remove("open");
        });
        const btnEl = document.getElementById(btnMap[id]);
        if (btnEl) {
          const bRect = btnEl.getBoundingClientRect();
          const hRect = host.getBoundingClientRect();
          const panelW = Math.max(panel.offsetWidth || 300, 300);
          let left = bRect.left - hRect.left;
          left = Math.min(left, Math.max(0, hRect.width - panelW - 4));
          panel.style.left = left + "px";
        }
        panel.classList.add("open");
      }

      function closePanel(id) {
        document.getElementById(id)?.classList.remove("open");
      }

      document.getElementById("ppDrawClose").addEventListener("click", () => {
        if (editingPath) {
          stopPathEdit();
          setTool("draw");
        }
        closePanel("ppDraw");
      });
      document.getElementById("ppTextClose").addEventListener("click", () => {
        stopTextEdit();
        closePanel("ppText");
      });
      document.getElementById("ppShapeClose").addEventListener("click", () => {
        stopShapeEdit();
        closePanel("ppShape");
      });
      document.getElementById("ppImageClose").addEventListener("click", () => {
        stopImageEdit();
        closePanel("ppImage");
      });

      /* ═══════════════════════════════════════════════════════
         TOOLBAR WIRING
      ═══════════════════════════════════════════════════════ */
      document.getElementById("tbDraw").addEventListener("click", () => {
        if (curTool === "draw")
          document.getElementById("ppDraw").classList.toggle("open");
        else {
          setTool("draw");
          openPanel("ppDraw");
        }
      });

      document.getElementById("tbText").addEventListener("click", () => {
        if (curTool === "text")
          document.getElementById("ppText").classList.toggle("open");
        else {
          stopPathEdit();
          setTool("text");
          openPanel("ppText");
        }
      });

      document.getElementById("btnAddText").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const it = new fabric.IText("Double-click to edit", {
          left: fc.width / 2,
          top: fc.height / 2,
          originX: "center",
          originY: "center",
          fontFamily: document.getElementById("tFont").value,
          fontSize: parseInt(document.getElementById("tSize").value),
          fill: document.getElementById("tColor").value,
          fontWeight: document.getElementById("tWeight").value,
          textAlign: getTextAlign(),
          editable: true,
        });
        fc.add(it);
        fc.setActiveObject(it);
        fc.renderAll();
        setTool("none");
        closePanel("ppText");
        showAnnotBar(fc);
        toast("Text added — double-click to edit", "s");
      });

      document.getElementById("tbShape").addEventListener("click", () => {
        if (curTool === "shape")
          document.getElementById("ppShape").classList.toggle("open");
        else {
          stopPathEdit();
          stopTextEdit();
          setTool("shape");
          openPanel("ppShape");
        }
      });

      document.getElementById("btnAddShape").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const fill = document.getElementById("sFill").value;
        const str = document.getElementById("sStroke").value;
        const sw = parseInt(document.getElementById("sStrokeW").value) || 2;
        const type = document.getElementById("sType").value;
        const cx = fc.width / 2,
          cy = fc.height / 2;
        let obj;
        if (type === "rect")
          obj = new fabric.Rect({
            left: cx - 75,
            top: cy - 50,
            width: 150,
            height: 100,
            fill,
            stroke: str,
            strokeWidth: sw,
          });
        else if (type === "circle")
          obj = new fabric.Circle({
            left: cx - 60,
            top: cy - 60,
            radius: 60,
            fill,
            stroke: str,
            strokeWidth: sw,
          });
        else if (type === "triangle")
          obj = new fabric.Triangle({
            left: cx - 60,
            top: cy - 60,
            width: 120,
            height: 100,
            fill,
            stroke: str,
            strokeWidth: sw,
          });
        else if (type === "line")
          obj = new fabric.Line([cx - 80, cy, cx + 80, cy], {
            stroke: str,
            strokeWidth: sw + 1,
            selectable: true,
          });
        if (obj) {
          fc.add(obj);
          fc.setActiveObject(obj);
          fc.renderAll();
          setTool("none");
          closePanel("ppShape");
          showAnnotBar(fc);
          toast("Shape added", "s");
        }
      });

      document.getElementById("tbImage").addEventListener("click", () => {
        stopPathEdit();
        stopTextEdit();
        stopShapeEdit();
        stopImageEdit();
        setTool("image");
        document
          .querySelectorAll(".prop-panel")
          .forEach((p) => p.classList.remove("open"));
        document.getElementById("imgInput").click();
      });

      document.getElementById("imgInput").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          fabric.Image.fromURL(ev.target.result, (img) => {
            const fc = getFC();
            if (!fc) return;
            const max = Math.min(fc.width, fc.height) * 0.5;
            if (img.width > max) img.scaleToWidth(max);
            img.set({
              left: fc.width / 2 - img.getScaledWidth() / 2,
              top: fc.height / 2 - img.getScaledHeight() / 2,
            });
            img._cornerRadius = 0;
            fc.add(img);
            fc.setActiveObject(img);
            fc.renderAll();
            curTool = "none";
            Object.entries(TOOL_IDS).forEach(([, id]) =>
              document.getElementById(id).classList.remove("on"),
            );
            applyTool(fc);
            showAnnotBar(fc);
            toast(
              "Image added — click Edit to adjust opacity & corner radius",
              "s",
            );
          });
        };
        reader.readAsDataURL(file);
        e.target.value = "";
      });

      document.getElementById("tbUndo").addEventListener("click", () => {
        const fc = getFC();
        if (!fc) return;
        const objs = fc.getObjects();
        if (objs.length) {
          fc.remove(objs[objs.length - 1]);
          hideAnnotBar();
          stopPathEdit();
          stopTextEdit();
          stopShapeEdit();
          stopImageEdit();
          toast("Undone", "i");
        }
      });

      document.getElementById("tbClear").addEventListener("click", async () => {
        const ok = await mConfirm(
          "Clear all annotations on this page?",
          "Clear Page",
        );
        if (!ok) return;
        const fc = getFC();
        if (!fc) return;
        fc.clear();
        fc.setBackgroundColor("rgba(0,0,0,0)", fc.renderAll.bind(fc));
        hideAnnotBar();
        stopPathEdit();
        stopTextEdit();
        stopShapeEdit();
        stopImageEdit();
        toast("Page cleared", "i");
      });

      document
        .getElementById("btnClose")
        .addEventListener("click", async () => {
          const ok = await mConfirm(
            "Remove this PDF? All edits will be lost.",
            "Remove PDF",
            true,
          );
          if (!ok) return;
          pages.forEach((p) => p.fabricCanvas.dispose());
          pages = [];
          pdfDoc = null;
          pdfFile = null;
          curIdx = 0;
          document.getElementById("canvasArea").innerHTML = "";
          document.getElementById("sidebar").innerHTML =
            '<div class="sb-title">Pages</div>';
          document.getElementById("editorScreen").classList.remove("show");
          document.getElementById("uploadScreen").style.display = "flex";
          document.getElementById("fileInput").value = "";
          hideAnnotBar();
          document
            .querySelectorAll(".prop-panel")
            .forEach((p) => p.classList.remove("open"));
          stopPathEdit();
          stopTextEdit();
          stopShapeEdit();
          stopImageEdit();
        });

      /* Outside click */
      document.addEventListener("click", (e) => {
        if (
          e.target.closest(".prop-panel") ||
          e.target.closest(".tbtn") ||
          e.target.closest("#annotBar") ||
          e.target.closest("#modalOverlay")
        )
          return;
        if (!editingText) closePanel("ppText");
        if (!editingShape) closePanel("ppShape");
        if (!editingImage) closePanel("ppImage");
      });

      /* Keyboard */
      document.addEventListener("keydown", (e) => {
        if (
          (e.key === "Delete" || e.key === "Backspace") &&
          !["INPUT", "TEXTAREA", "SELECT"].includes(
            document.activeElement.tagName,
          )
        ) {
          document.getElementById("abDel").click();
        }
        if (e.key === "Escape") {
          if (editingPath) {
            stopPathEdit();
            closePanel("ppDraw");
            setTool("draw");
            openPanel("ppDraw");
          } else if (editingText) {
            stopTextEdit();
            closePanel("ppText");
          } else if (editingShape) {
            stopShapeEdit();
            closePanel("ppShape");
          } else if (editingImage) {
            stopImageEdit();
            closePanel("ppImage");
          } else {
            closePanel("ppText");
            closePanel("ppShape");
            closePanel("ppImage");
          }
        }
      });

      /* ═══════════════════════════════════════════════════════
         EDIT CONTENT
      ═══════════════════════════════════════════════════════ */
      document
        .getElementById("tbEditContent")
        .addEventListener("click", async () => {
          if (!pdfFile) {
            toast("Load a PDF first", "e");
            return;
          }
          const btn = document.getElementById("tbEditContent");
          btn.disabled = true;
          btn.innerHTML =
            '<i class="fa fa-spinner fa-spin"></i><span>Extracting…</span>';
          try {
            const pageNum = pages[curIdx].pageNum;
            const scale = pages[curIdx].scale;
            const fc = getFC();
            const fd = new FormData();
            fd.append("file", pdfFile);
            fd.append("pageNum", pageNum);
            const res = await fetch(`${API}/extract-edit-content`, {
              method: "POST",
              body: fd,
            });
            if (!res.ok) {
              const err = await res
                .json()
                .catch(() => ({ error: res.statusText }));
              throw new Error(err.error || res.statusText);
            }
            const data = await res.json();
            const textBlocks = data.textBlocks || [];
            const images = data.images || [];
            if (!textBlocks.length && !images.length) {
              toast("No editable content found on this page", "i");
              return;
            }
            if (data.cleanedPagePdf) {
              const pdfBytes = Uint8Array.from(atob(data.cleanedPagePdf), (c) =>
                c.charCodeAt(0),
              );
              const cleanDoc = await pdfjsLib.getDocument({ data: pdfBytes })
                .promise;
              const cleanPage = await cleanDoc.getPage(pageNum);
              const vp = cleanPage.getViewport({ scale });
              const ctx = pages[curIdx].pdfCvs.getContext("2d");
              ctx.clearRect(
                0,
                0,
                pages[curIdx].pdfCvs.width,
                pages[curIdx].pdfCvs.height,
              );
              await cleanPage.render({ canvasContext: ctx, viewport: vp })
                .promise;
            }
            let placed = 0;
            for (const tb of textBlocks) {
              const it = new fabric.IText(tb.text || "", {
                left: tb.x * scale,
                top: tb.y * scale,
                fontFamily: tb.fontFamily || "Arial",
                fontSize: Math.max(
                  6,
                  (tb.originalHeight ?? tb.height) * scale * 0.88,
                ),
                fill: tb.color || "#000000",
                fontWeight: tb.fontWeight || "normal",
                fontStyle: tb.fontStyle || "normal",
                editable: true,
                selectable: true,
              });
              fc.add(it);
              placed++;
            }
            for (const img of images) {
              if (!img.dataUrl) continue;
              await new Promise((resolve) => {
                fabric.Image.fromURL(img.dataUrl, (fimg) => {
                  fimg.set({
                    left: img.x * scale,
                    top: img.y * scale,
                    scaleX: (img.width * scale) / (fimg.width || 1),
                    scaleY: (img.height * scale) / (fimg.height || 1),
                    selectable: true,
                    hasControls: true,
                  });
                  fimg._cornerRadius = 0;
                  fc.add(fimg);
                  placed++;
                  resolve();
                });
              });
            }
            fc.renderAll();
            setTool("none");
            if (data.cleanedFullPdf) {
              const bytes = Uint8Array.from(atob(data.cleanedFullPdf), (c) =>
                c.charCodeAt(0),
              );
              pdfFile = new File([bytes], pdfFile.name, {
                type: "application/pdf",
              });
            }
            toast(
              `${placed} item(s) extracted & placed — originals removed`,
              "s",
            );
          } catch (err) {
            console.error(err);
            toast("Extract failed: " + err.message, "e");
          } finally {
            btn.disabled = false;
            btn.innerHTML =
              '<i class="fa fa-file-pen"></i><span>Edit Content</span>';
          }
        });

      /* ═══════════════════════════════════════════════════════
         SAVE PDF
      ═══════════════════════════════════════════════════════ */
      let savedBlob = null,
        savedObjectURL = null;

      function showSaveScreen(blob, filename) {
        if (savedObjectURL) URL.revokeObjectURL(savedObjectURL);
        savedBlob = blob;
        savedObjectURL = URL.createObjectURL(blob);
        document.getElementById("saveFname").textContent = filename;
        document.getElementById("savePreview").src = savedObjectURL;
        document.getElementById("editorScreen").classList.remove("show");
        document.getElementById("saveScreen").classList.add("show");
      }

      function hideSaveScreen() {
        document.getElementById("saveScreen").classList.remove("show");
      }

      document.getElementById("tbSave").addEventListener("click", async () => {
        if (!pdfFile) {
          await mAlert("Please load a PDF first.");
          return;
        }
        const btn = document.getElementById("tbSave");
        btn.disabled = true;
        btn.innerHTML =
          '<i class="fa fa-spinner fa-spin"></i><span>Saving…</span>';
        try {
          const fd = new FormData();
          fd.append("file", pdfFile);
          const annData = pages.map((p) => ({
            pageNum: p.pageNum,
            canvasWidth: p.fabricCanvas.width,
            canvasHeight: p.fabricCanvas.height,
            drawing: p.fabricCanvas.getObjects().length
              ? p.fabricCanvas.toDataURL({ format: "png", multiplier: 1 })
              : null,
            annotations: [],
            deletedRegions: [],
            deletedImages: [],
          }));
          fd.append("annotations", JSON.stringify(annData));
          const res = await fetch(`${API}/edit-pdf`, {
            method: "POST",
            body: fd,
          });
          if (!res.ok) throw new Error(await res.text());
          const blob = await res.blob();
          showSaveScreen(blob, "edited_" + pdfFile.name);
          toast("PDF saved — preview ready!", "s");
        } catch (err) {
          console.error(err);
          await mAlert("Save failed: " + err.message, "Error");
        } finally {
          btn.disabled = false;
          btn.innerHTML =
            '<i class="fa fa-floppy-disk"></i><span>Save PDF</span>';
        }
      });

      document.getElementById("savDownload").addEventListener("click", () => {
        if (!savedBlob) return;
        const a = document.createElement("a");
        a.href = savedObjectURL;
        a.download = document.getElementById("saveFname").textContent;
        a.click();
        toast("Downloading…", "s");
      });

      document
        .getElementById("savShare")
        .addEventListener("click", async () => {
          if (!savedBlob) return;
          const filename = document.getElementById("saveFname").textContent;
          if (navigator.share && navigator.canShare) {
            try {
              const file = new File([savedBlob], filename, {
                type: "application/pdf",
              });
              if (navigator.canShare({ files: [file] })) {
                await navigator.share({ files: [file], title: filename });
                return;
              }
            } catch (e) {}
          }
          try {
            await navigator.clipboard.writeText(savedObjectURL);
            toast("Link copied to clipboard!", "s");
          } catch {
            toast("Share not supported on this browser", "e");
          }
        });

      document
        .getElementById("savReset")
        .addEventListener("click", async () => {
          const ok = await mConfirm(
            "Start over? The current edited PDF will be discarded.",
            "Reset",
            true,
          );
          if (!ok) return;
          pages.forEach((p) => p.fabricCanvas.dispose());
          pages = [];
          pdfDoc = null;
          pdfFile = null;
          curIdx = 0;
          document.getElementById("canvasArea").innerHTML = "";
          document.getElementById("sidebar").innerHTML =
            '<div class="sb-title">Pages</div>';
          document.getElementById("fileInput").value = "";
          hideAnnotBar();
          document
            .querySelectorAll(".prop-panel")
            .forEach((p) => p.classList.remove("open"));
          stopPathEdit();
          stopTextEdit();
          stopShapeEdit();
          stopImageEdit();
          hideSaveScreen();
          document.getElementById("uploadScreen").style.display = "flex";
          if (savedObjectURL) {
            URL.revokeObjectURL(savedObjectURL);
            savedObjectURL = null;
          }
          savedBlob = null;
          toast("Reset — upload a new PDF to start", "i");
        });

      document.getElementById("savEditPdf").addEventListener("click", () => {
        hideSaveScreen();
        document.getElementById("editorScreen").classList.add("show");
        toast("Back to editor", "i");
      });

      let _rt;
      window.addEventListener("resize", () => {
        clearTimeout(_rt);
        _rt = setTimeout(() => {
          const fc = getFC();
          if (fc?.getActiveObject()) posAnnotBar(fc);
        }, 150);
      });
    </script>
  </body>
</html>
