<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Remove Watermark from PDF Online Free | NextoPDF</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Inter:wght@400;500&display=swap"
      rel="stylesheet"
    />

    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <!-- Main CSS -->
    <link rel="stylesheet" href="./css/style.css" />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="./images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="./images/favicon-16x16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="./images/apple-touch-icon.png"
    />

    <style>
      .pages-grid {
        display: flex;
        flex-direction: column;
        gap: 30px;
        margin-top: 20px;
        align-items: center;
      }

      .page-card {
        position: relative;
        background: white;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        width: fit-content;
        max-width: 100%;
        transition: all 0.3s ease;
      }

      @media (max-width: 768px) {
        .page-card {
          padding: 15px;
        }
      }

      .page-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .page-canvas-container {
        position: relative;
        display: inline-block;
        line-height: 0;
      }

      .page-card canvas {
        display: block;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
        max-width: 100% !important;
        height: auto !important;
      }

      .page-number-badge {
        position: absolute;
        top: -8px;
        left: 8px;
        background: #4f46e5;
        color: white;
        padding: 6px 12px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
        z-index: 5;
      }

      @media (max-width: 768px) {
        .page-number-badge {
          font-size: 12px;
          padding: 5px 10px;
        }
      }

      .watermark-overlay {
        position: absolute;
        cursor: pointer;
        user-select: none;
        z-index: 10;
        transition: all 0.2s ease;
        box-sizing: border-box;
        pointer-events: auto;
      }

      .watermark-overlay.type-text,
      .watermark-overlay.type-image {
        background: rgba(239, 68, 68, 0.15);
        outline: 2px solid rgba(239, 68, 68, 0.3);
        outline-offset: -2px;
      }

      .watermark-overlay.type-text:hover,
      .watermark-overlay.type-image:hover {
        outline-color: #ef4444 !important;
        background: rgba(239, 68, 68, 0.25) !important;
        z-index: 999;
      }

      .watermark-overlay.selected {
        outline-color: #ef4444 !important;
        background: rgba(239, 68, 68, 0.3) !important;
        outline-style: solid !important;
        outline-width: 3px !important;
      }

      .watermark-overlay.deleted {
        display: none;
      }

      .overlay-label {
        position: absolute;
        top: -22px;
        left: 0;
        background: #1e40af;
        color: white;
        padding: 9px 4px;
        font-size: 11px;
        border-radius: 4px;
        white-space: nowrap;
        display: none;
        z-index: 30;
        max-width: 250px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-weight: 500;
      }

      @media (max-width: 768px) {
        .overlay-label {
          font-size: 10px;
          padding: 6px 6px;
          max-width: 200px;
          top: -14px;
        }
      }

      @media (max-width: 480px) {
        .overlay-label {
          font-size: 9px;
          padding: 5px 5px;
          max-width: 150px;
          top: -12px;
        }
      }

      .watermark-overlay:hover .overlay-label {
        display: block;
      }

      .delete-icon {
        position: absolute;
        top: -10px;
        right: -10px;
        background: #ef4444;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        z-index: 20;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        flex-shrink: 0;
      }

      @media (max-width: 768px) {
        .delete-icon {
          width: 20px;
          height: 20px;
          font-size: 10px;
          top: -8px;
          right: -8px;
        }
      }

      @media (max-width: 480px) {
        .delete-icon {
          width: 18px;
          height: 18px;
          font-size: 9px;
          top: -6px;
          right: -6px;
        }
      }

      .delete-icon i {
        font-size: inherit;
      }

      .watermark-overlay.selected .delete-icon {
        display: flex;
      }

      .delete-icon:hover {
        background: #dc2626;
        transform: scale(1.1);
      }

      #controlPanel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        border-top: 3px solid #ef4444;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        padding: 15px;
        display: none;
      }

      @media (max-width: 768px) {
        #controlPanel {
          padding: 12px 10px;
        }
      }

      #controlPanel.show {
        display: block;
      }

      .control-content {
        max-width: 1200px;
        margin: 0 auto;
        text-align: center;
      }

      .selection-info {
        font-size: 15px;
        color: #1e3a8a;
        margin-bottom: 12px;
        font-weight: 600;
      }

      @media (max-width: 768px) {
        .selection-info {
          font-size: 14px;
          margin-bottom: 10px;
        }
      }

      @media (max-width: 480px) {
        .selection-info {
          font-size: 13px;
        }
      }

      .action-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      @media (max-width: 768px) {
        .action-buttons {
          gap: 8px;
        }
      }

      .action-buttons button {
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
      }

      @media (max-width: 768px) {
        .action-buttons button {
          padding: 10px 18px;
          font-size: 13px;
        }
      }

      @media (max-width: 480px) {
        .action-buttons button {
          padding: 10px 16px;
          font-size: 12px;
        }

        .action-buttons button i {
          font-size: 11px;
        }
      }

      .note-box {
        background: #f0f9ff;
        border-left: 4px solid #3b82f6;
        padding: 14px 18px;
        margin-top: 15px;
        font-size: 14px;
        border-radius: 4px;
        line-height: 1.6;
      }

      @media (max-width: 768px) {
        .note-box {
          font-size: 13px;
          padding: 12px 14px;
        }
      }

      @media (max-width: 480px) {
        .note-box {
          font-size: 12px;
          padding: 10px 12px;
        }
      }

      .success-message {
        background: #d1fae5;
        border-left: 4px solid #059669;
        padding: 14px 18px;
        margin-top: 15px;
        font-size: 14px;
        border-radius: 4px;
        color: #065f46;
        display: none;
        line-height: 1.6;
      }

      @media (max-width: 768px) {
        .success-message {
          font-size: 13px;
          padding: 12px 14px;
        }
      }

      @media (max-width: 480px) {
        .success-message {
          font-size: 12px;
          padding: 10px 12px;
        }
      }

      .success-message.show {
        display: block;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .loading-overlay.show {
        display: flex;
      }

      .loading-content {
        background: white;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
        max-width: 90%;
      }

      @media (max-width: 768px) {
        .loading-content {
          padding: 24px;
        }

        .loading-content p {
          font-size: 14px;
        }
      }

      @media (max-width: 480px) {
        .loading-content {
          padding: 20px;
        }

        .loading-content p {
          font-size: 13px;
        }
      }

      .spinner {
        border: 4px solid #f3f4f6;
        border-top: 4px solid #4f46e5;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* File list styling - borrowed from merge.html */
      .file-list {
        display: none;
        list-style: none;
        padding: 0;
        margin: 20px 0;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
      }

      .file-list li {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: all 0.2s ease;
      }

      @media (max-width: 768px) {
        .file-list li {
          padding: 10px 12px;
          gap: 10px;
        }
      }

      .file-list li:hover {
        border-color: #4f46e5;
        transform: translateX(4px);
      }

      .pdf-icon {
        color: #ef4444;
        font-size: 20px;
      }

      @media (max-width: 768px) {
        .pdf-icon {
          font-size: 18px;
        }
      }

      .file-list li span {
        flex: 1;
        color: #1f2937;
        font-weight: 500;
        font-size: 14px;
        word-break: break-word;
      }

      @media (max-width: 768px) {
        .file-list li span {
          font-size: 13px;
        }
      }

      @media (max-width: 480px) {
        .file-list li span {
          font-size: 12px;
        }
      }

      .delete-file {
        background: #ef4444;
        border: none;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: background 0.3s ease;
        flex-shrink: 0;
      }
      .delete-file i {
        color: #fff;
      }
      .delete-file:hover {
        background: #dc2626;
      }

      /* Responsive container adjustments */
      .merge-tool h1 {
        font-size: 2rem;
      }

      @media (max-width: 768px) {
        .merge-tool h1 {
          font-size: 1.5rem;
        }
      }

      @media (max-width: 480px) {
        .merge-tool h1 {
          font-size: 1.3rem;
        }
      }

      .merge-tool p {
        font-size: 1rem;
      }

      @media (max-width: 768px) {
        .merge-tool p {
          font-size: 0.9rem;
        }
      }

      @media (max-width: 480px) {
        .merge-tool p {
          font-size: 0.85rem;
        }
      }

      /* Error message styling */
      .error-text {
        background: #fee2e2;
        border-left: 4px solid #ef4444;
        padding: 12px 16px;
        font-size: 14px;
        border-radius: 4px;
        color: #991b1b;
        line-height: 1.6;
      }

      @media (max-width: 768px) {
        .error-text {
          font-size: 13px;
          padding: 10px 14px;
        }
      }

      @media (max-width: 480px) {
        .error-text {
          font-size: 12px;
          padding: 10px 12px;
        }
      }
    </style>
  </head>

  <body>
    <section id="header-placeholder"></section>

    <main>
      <section class="merge-tool">
        <div class="container">
          <h1>Remove Watermark from PDF Online</h1>
          <p>
            Upload your PDF and click on any text or image to select watermarks
            for removal. Uses PyMuPDF for accurate detection and permanent
            deletion.
          </p>

          <div class="upload-section">
            <div id="uploadSection">
              <label class="upload-label" for="pdfUpload">
                <i class="fa fa-upload"></i> Choose PDF file
              </label>
              <input type="file" id="pdfUpload" accept=".pdf" />
            </div>

            <!-- File list similar to merge.html -->
            <ul id="fileList" class="file-list"></ul>

            <div class="success-message" id="successMsg"></div>
            <div id="pagesGrid" class="pages-grid" style="display: none"></div>

            <div id="controlPanel">
              <div class="control-content">
                <p
                  class="error-text"
                  id="errorMsg"
                  style="display: none; margin-bottom: 10px"
                ></p>
                <div class="selection-info" id="selectionInfo">
                  No items selected
                </div>
                <div class="action-buttons">
                  <button id="clearBtn" class="secondary-btn">
                    <i class="fa fa-times"></i> Clear Selection
                  </button>
                  <button
                    id="deleteBtn"
                    class="cta-button"
                    style="background: #f59e0b"
                  >
                    <i class="fa fa-trash"></i> Delete Selected
                  </button>
                  <button id="removeBtn" class="cta-button">
                    <i class="fa fa-save"></i> Save Changes
                  </button>
                </div>
              </div>
            </div>

            <div class="note-box" id="noteBox">
              üí° <strong>How it works:</strong> Click on text or images to
              select them (red border appears). Selected items can be deleted
              individually or in batch. Then click "Save Changes" to download
              your cleaned PDF.
            </div>

            <div id="resultBtns" style="display: none; margin-top: 30px">
              <div class="result-card">
                <i class="fa fa-file-pdf"></i>
              </div>
              <p class="file-name">
                <a href="#" id="fileNameLink">cleaned.pdf</a>
              </p>
              <div class="result-btns-container">
                <a id="downloadBtn" href="#" class="cta-button" download>
                  <i class="fa fa-download"></i> Download
                </a>
                <a id="shareBtn" href="#" class="cta-button">
                  <i class="fa fa-share-alt"></i> Share
                </a>
                <button id="resetBtn" class="secondary-btn">
                  <i class="fa fa-rotate-right"></i> Remove Another
                </button>
              </div>
            </div>
          </div>

          <!-- PDF Preview -->
          <div id="pdfPreview" style="display: none; margin-top: 30px">
            <h2>Preview Cleaned PDF</h2>
            <iframe
              id="pdfFrame"
              width="100%"
              height="600"
              title="Cleaned PDF preview"
              style="border-radius: 12px; border: 1px solid #e5e7eb"
            ></iframe>
          </div>
        </div>
      </section>
    </main>

    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-content">
        <div class="spinner"></div>
        <p>Processing PDF...</p>
      </div>
    </div>

    <section id="footer-placeholder"></section>

    <script src="./js/app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Use BACKEND_BASE_URL from app.js or fallback to localhost
      const DETECT_URL = `${BACKEND_BASE_URL}/detect-watermarks`;
      const REMOVE_URL = `${BACKEND_BASE_URL}/remove-watermark`;

      const pdfUpload = document.getElementById("pdfUpload");
      const uploadSection = document.getElementById("uploadSection");
      const fileList = document.getElementById("fileList");
      const pagesGrid = document.getElementById("pagesGrid");
      const controlPanel = document.getElementById("controlPanel");
      const selectionInfo = document.getElementById("selectionInfo");
      const clearBtn = document.getElementById("clearBtn");
      const deleteBtn = document.getElementById("deleteBtn");
      const removeBtn = document.getElementById("removeBtn");
      const errorMsg = document.getElementById("errorMsg");
      const successMsg = document.getElementById("successMsg");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const resultBtns = document.getElementById("resultBtns");
      const downloadBtn = document.getElementById("downloadBtn");
      const shareBtn = document.getElementById("shareBtn");
      const resetBtn = document.getElementById("resetBtn");
      const noteBox = document.getElementById("noteBox");
      const pdfPreview = document.getElementById("pdfPreview");
      const pdfFrame = document.getElementById("pdfFrame");
      const fileNameLink = document.getElementById("fileNameLink");

      let currentFile = null;
      let detectedItems = [];
      let selectedItems = new Set();
      let pageRenderScales = {}; // Store the actual render scale for each page

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      function showError(msg) {
        errorMsg.textContent = msg;
        errorMsg.style.display = "inline-block";
        successMsg.classList.remove("show");
      }

      function clearError() {
        errorMsg.style.display = "none";
      }

      function showSuccess(msg) {
        successMsg.textContent = msg;
        successMsg.classList.add("show");
        clearError();
        setTimeout(() => successMsg.classList.remove("show"), 3000);
      }

      function showLoading() {
        loadingOverlay.classList.add("show");
      }

      function hideLoading() {
        loadingOverlay.classList.remove("show");
      }

      function updateSelectionInfo() {
        const selectedCount = selectedItems.size;
        if (selectedCount === 0) {
          selectionInfo.textContent = "No items selected";
        } else {
          selectionInfo.textContent = `${selectedCount} item${selectedCount > 1 ? "s" : ""} selected`;
        }
      }

      // Render file list (like merge.html)
      function renderFileList() {
        fileList.style.display = "block";
        fileList.innerHTML = "";

        const li = document.createElement("li");
        li.innerHTML = `<i class="fa fa-file-pdf pdf-icon"></i> <span>${currentFile.name}</span> <button class="delete-file" id="deleteFileBtn"><i class="fa fa-times"></i></button>`;
        fileList.appendChild(li);
      }

      // Handle file deletion
      fileList.addEventListener("click", (e) => {
        const deleteBtn = e.target.closest(".delete-file");
        if (deleteBtn) {
          resetApplication();
        }
      });

      // Proper reset function without page reload
      function resetApplication() {
        // Clear all data
        currentFile = null;
        detectedItems = [];
        selectedItems.clear();
        pageRenderScales = {};

        // Reset UI elements
        fileList.style.display = "none";
        fileList.innerHTML = "";
        uploadSection.style.display = "block";
        pagesGrid.style.display = "none";
        pagesGrid.innerHTML = "";
        controlPanel.style.display = "none";
        resultBtns.style.display = "none";
        pdfPreview.style.display = "none";
        noteBox.style.display = "block";

        // Reset file input
        pdfUpload.value = "";

        // Clear messages
        clearError();
        successMsg.classList.remove("show");

        // Reset iframe
        pdfFrame.src = "";

        // Reset download links
        if (downloadBtn.href && downloadBtn.href.startsWith("blob:")) {
          URL.revokeObjectURL(downloadBtn.href);
        }
        if (shareBtn.href && shareBtn.href.startsWith("blob:")) {
          URL.revokeObjectURL(shareBtn.href);
        }
        downloadBtn.href = "#";
        shareBtn.href = "#";

        // Scroll to top
        window.scrollTo({ top: 0, behavior: "smooth" });
      }

      // Upload PDF and detect watermarks - OPTIMIZED FOR MOBILE
      pdfUpload.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        clearError();
        currentFile = file;
        selectedItems.clear();
        detectedItems = [];
        pageRenderScales = {};

        // Hide upload button and show file list
        uploadSection.style.display = "none";
        renderFileList();

        showLoading();

        // Check file size for mobile
        const isMobile = window.innerWidth <= 768;
        const maxFileSizeMobile = 20 * 1024 * 1024; // 20MB for mobile

        if (isMobile && file.size > maxFileSizeMobile) {
          hideLoading();
          showError(
            "File too large for mobile. Please use a smaller PDF (under 20MB) or try on desktop.",
          );
          // Keep the file but warn user
          successMsg.textContent =
            "Warning: Large file on mobile. Some features may be limited.";
          successMsg.style.background = "#fef3c7";
          successMsg.style.borderLeftColor = "#f59e0b";
          successMsg.style.color = "#92400e";
          successMsg.classList.add("show");

          // Still try to process but with optimizations
        }

        try {
          // Detect watermarks from backend
          const formData = new FormData();
          formData.append("file", file);

          const detectRes = await fetch(DETECT_URL, {
            method: "POST",
            body: formData,
          });

          if (!detectRes.ok) {
            const errorData = await detectRes.json().catch(() => ({}));
            throw new Error(errorData.error || "Failed to detect watermarks");
          }

          const detectData = await detectRes.json();
          detectedItems = detectData.items || [];

          // Optimize for mobile - limit items if too many
          if (isMobile && detectedItems.length > 100) {
            console.warn(
              `Too many items (${detectedItems.length}) for mobile, showing first 100`,
            );
            detectedItems = detectedItems.slice(0, 100);
            showSuccess(
              `‚úì Detected ${detectedItems.length} items (limited for mobile performance)`,
            );
          } else {
            showSuccess(
              `‚úì Detected ${detectedItems.length} item${detectedItems.length !== 1 ? "s" : ""} (text and images)`,
            );
          }

          await renderPDFWithOverlays(file, detectedItems);

          hideLoading();
          controlPanel.style.display = "block";
          pagesGrid.style.display = "flex";

          // Scroll to first page on mobile
          if (isMobile) {
            setTimeout(() => {
              pagesGrid.scrollIntoView({ behavior: "smooth", block: "start" });
            }, 500);
          }
        } catch (error) {
          hideLoading();
          showError("Error: " + error.message);
          console.error("PDF Upload Error:", error);
          // Reset UI on error
          resetApplication();
        }
      };

      // Calculate display scale based on viewport - OPTIMIZED FOR ALL SCREEN SIZES
      function calculateDisplayScale(pdfPageWidth) {
        const container = pagesGrid.closest(".container");
        const containerWidth = container
          ? container.clientWidth
          : window.innerWidth;

        // Account for padding and margins
        let maxWidth;

        if (window.innerWidth < 480) {
          // Very small screens - optimize for performance
          maxWidth = Math.min(containerWidth - 20, 320);
        } else if (window.innerWidth < 768) {
          // Mobile - balance quality and performance
          maxWidth = Math.min(containerWidth - 40, 450);
        } else if (window.innerWidth < 970) {
          // Medium screens (768-970px)
          maxWidth = Math.min(containerWidth - 60, 650);
        } else {
          // Desktop
          maxWidth = Math.min(containerWidth - 100, 800);
        }

        // Ensure we don't scale below a minimum width
        maxWidth = Math.max(maxWidth, 200);

        // Calculate scale to fit the PDF page width to display width
        return maxWidth / pdfPageWidth;
      }

      // Get pixel ratio with fallback for optimal rendering
      function getPixelRatio() {
        // For mobile, use lower pixel ratio to prevent blurry text
        const isMobile = window.innerWidth <= 768;
        const devicePixelRatio = window.devicePixelRatio || 1;

        if (isMobile) {
          // On mobile, use devicePixelRatio but cap it to prevent blur
          return Math.min(devicePixelRatio, 2);
        } else {
          // On desktop, use full devicePixelRatio
          return Math.min(devicePixelRatio, 2.5);
        }
      }

      // Render PDF pages with overlays - OPTIMIZED FOR CRISP TEXT
      async function renderPDFWithOverlays(file, items) {
        pagesGrid.innerHTML = "";
        pageRenderScales = {};

        try {
          const fileURL = URL.createObjectURL(file);

          const loadingTask = pdfjsLib.getDocument({
            url: fileURL,
            cMapUrl: "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/",
            cMapPacked: true,
            verbosity: 0,
            // Optimize for mobile
            disableFontFace: false, // Keep font face enabled for crisp text
            disableRange: false,
            disableStream: false,
          });

          const pdf = await loadingTask.promise;

          // Group items by page
          const itemsByPage = {};
          items.forEach((item, idx) => {
            item.id = idx;
            const page = item.page;
            if (!itemsByPage[page]) itemsByPage[page] = [];
            itemsByPage[page].push(item);
          });

          // Limit number of pages rendered at once on mobile
          const isMobile = window.innerWidth <= 768;
          const maxPagesToRender = isMobile ? 5 : pdf.numPages;

          console.log(
            `Rendering ${Math.min(maxPagesToRender, pdf.numPages)} of ${pdf.numPages} pages`,
          );

          // Render pages sequentially
          for (
            let pageNum = 1;
            pageNum <= Math.min(maxPagesToRender, pdf.numPages);
            pageNum++
          ) {
            try {
              const page = await pdf.getPage(pageNum);
              const viewport = page.getViewport({ scale: 1 });

              // Calculate display scale based on viewport width
              const displayScale = calculateDisplayScale(viewport.width);

              // Store the display scale for this page
              pageRenderScales[pageNum] = displayScale;

              // Get pixel ratio for crisp rendering
              const pixelRatio = getPixelRatio();

              // Calculate render scale - ensure it's a multiple of displayScale for crisp text
              let renderScale;
              if (window.innerWidth < 480) {
                // Small screens: use 1.5x for readability
                renderScale = displayScale * Math.max(1.5, pixelRatio * 0.8);
              } else if (window.innerWidth < 768) {
                // Mobile: use balanced scale
                renderScale = displayScale * Math.max(1.8, pixelRatio * 0.9);
              } else if (window.innerWidth < 970) {
                // Medium screens
                renderScale = displayScale * Math.max(2.0, pixelRatio);
              } else {
                // Desktop: full quality
                renderScale = displayScale * pixelRatio;
              }

              // Round to nearest 0.25 to prevent sub-pixel rendering issues
              renderScale = Math.round(renderScale * 4) / 4;

              const scaledViewport = page.getViewport({ scale: renderScale });

              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d", {
                willReadFrequently: false,
                alpha: false,
              });

              // Set canvas dimensions with proper pixel ratio
              canvas.width = Math.floor(scaledViewport.width);
              canvas.height = Math.floor(scaledViewport.height);

              // Set display dimensions
              const displayWidth = viewport.width * displayScale;
              const displayHeight = viewport.height * displayScale;

              canvas.style.width = displayWidth + "px";
              canvas.style.height = displayHeight + "px";

              // Set CSS image rendering for crisp text
              canvas.style.imageRendering = "-webkit-optimize-contrast";
              canvas.style.imageRendering = "crisp-edges";
              canvas.style.imageRendering = "pixelated";

              // Clear canvas with white background
              context.fillStyle = "white";
              context.fillRect(0, 0, canvas.width, canvas.height);

              // Set rendering hints for better text quality
              context.imageSmoothingEnabled = false;
              context.textDrawingMode = "glyph"; // Use glyph mode for better text rendering
              context.fontKerning = "normal";

              const renderTask = page.render({
                canvasContext: context,
                viewport: scaledViewport,
                intent: "display",
                enableWebGL: false,
                renderInteractiveForms: false,
                // Optimize for text quality
                imageLayer: true,
                annotationLayer: false,
                renderer: "canvas",
                useWorkerFetch: false,
                isEvalSupported: false,
                enableXfa: false,
              });

              await renderTask.promise;

              const card = document.createElement("div");
              card.className = "page-card";
              card.dataset.pageNum = pageNum;
              card.style.maxWidth = displayWidth + "px";
              card.style.width = displayWidth + "px";

              const badge = document.createElement("div");
              badge.className = "page-number-badge";
              badge.textContent = `Page ${pageNum}`;
              card.appendChild(badge);

              const container = document.createElement("div");
              container.className = "page-canvas-container";
              container.style.position = "relative";
              container.style.width = displayWidth + "px";
              container.style.height = displayHeight + "px";
              container.style.margin = "0 auto";
              container.style.overflow = "hidden"; // Prevent canvas bleeding
              container.appendChild(canvas);

              // Add overlays with correct scale
              const pageItems = itemsByPage[pageNum] || [];
              pageItems.forEach((item) => {
                const overlay = createOverlay(item, displayScale);
                container.appendChild(overlay);
              });

              card.appendChild(container);
              pagesGrid.appendChild(card);

              // Clean up page to free memory (important for mobile)
              page.cleanup();

              // Small delay to prevent UI blocking on mobile
              if (isMobile && pageNum % 2 === 0) {
                await new Promise((resolve) => setTimeout(resolve, 50));
              }
            } catch (pageError) {
              console.error(`Error rendering page ${pageNum}:`, pageError);
              // Continue with other pages even if one fails
            }
          }

          URL.revokeObjectURL(fileURL);

          // Show message if we limited pages
          if (isMobile && maxPagesToRender < pdf.numPages) {
            const remainingPages = pdf.numPages - maxPagesToRender;
            const infoDiv = document.createElement("div");
            infoDiv.className = "note-box";
            infoDiv.style.marginTop = "10px";
            infoDiv.innerHTML = `üì± <strong>Mobile View:</strong> Showing first ${maxPagesToRender} pages. Watermark removal will still work on all pages.`;
            pagesGrid.appendChild(infoDiv);
          }

          // Check file size and show warning for mobile
          if (isMobile && file.size > 10 * 1024 * 1024) {
            // 10MB threshold
            setTimeout(() => {
              showMemoryWarning();
            }, 1000);
          }

          pdf.destroy();
        } catch (error) {
          console.error("Error in renderPDFWithOverlays:", error);
          throw error;
        }
      }

      function createOverlay(item, displayScale) {
        const [x0, y0, x1, y1] = item.bbox;

        const overlay = document.createElement("div");
        overlay.className = `watermark-overlay type-${item.type}`;
        overlay.dataset.itemId = item.id;
        overlay.dataset.pageNum = item.page;

        // Use displayScale directly with proper positioning
        const left = x0 * displayScale;
        const top = y0 * displayScale;
        const width = (x1 - x0) * displayScale;
        const height = (y1 - y0) * displayScale;

        overlay.style.position = "absolute";
        overlay.style.left = left + "px";
        overlay.style.top = top + "px";
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
        overlay.style.boxSizing = "border-box";
        overlay.style.backfaceVisibility = "hidden"; // Prevent blurriness
        overlay.style.transform = "translateZ(0)"; // Force GPU rendering for crisp edges

        // Label
        const label = document.createElement("div");
        label.className = "overlay-label";
        label.textContent =
          item.type === "text"
            ? `Text: ${item.text?.substring(0, 30) || "N/A"}`
            : "Image";
        label.style.backfaceVisibility = "hidden";
        label.style.transform = "translateZ(0)";
        overlay.appendChild(label);

        // Delete icon
        const deleteIcon = document.createElement("div");
        deleteIcon.className = "delete-icon";
        deleteIcon.innerHTML = '<i class="fa fa-times"></i>';
        deleteIcon.style.backfaceVisibility = "hidden";
        deleteIcon.style.transform = "translateZ(0)";
        overlay.appendChild(deleteIcon);

        overlay.onclick = (e) => {
          if (e.target.closest(".delete-icon")) return;
          toggleSelection(item.id, overlay);
        };
        deleteIcon.onclick = (e) => {
          e.stopPropagation();
          deleteWatermark(item.id, overlay);
        };

        return overlay;
      }

      function toggleSelection(itemId, overlay) {
        if (selectedItems.has(itemId)) {
          selectedItems.delete(itemId);
          overlay.classList.remove("selected");
        } else {
          selectedItems.add(itemId);
          overlay.classList.add("selected");
          clearError();
        }
        updateSelectionInfo();
      }

      // Delete single watermark immediately and update preview - WITH MOBILE OPTIMIZATION
      async function deleteWatermark(itemId, overlay) {
        const item = detectedItems.find((i) => i.id === itemId);
        if (!item) return;

        showLoading();
        clearError();

        // Show processing message for mobile
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
          const processingMsg = document.createElement("div");
          processingMsg.className = "success-message";
          processingMsg.style.background = "#f0f9ff";
          processingMsg.style.borderLeftColor = "#3b82f6";
          processingMsg.style.color = "#1e40af";
          processingMsg.textContent = "Processing... Please wait";
          pagesGrid.insertBefore(processingMsg, pagesGrid.firstChild);
        }

        try {
          const formData = new FormData();
          formData.append("files", currentFile);
          formData.append("watermarks", JSON.stringify([item]));

          const res = await fetch(REMOVE_URL, {
            method: "POST",
            body: formData,
          });

          if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            let errorMessage = errorData.error || "Failed to remove watermark";

            // Mobile-specific error messages
            if (isMobile && errorMessage.includes("too large")) {
              errorMessage =
                "File too large for mobile processing. Please try on desktop or with a smaller PDF.";
            }

            throw new Error(errorMessage);
          }

          const blob = await res.blob();
          currentFile = new File([blob], currentFile.name, {
            type: "application/pdf",
          });

          const deletedPageNum = item.page;

          detectedItems = detectedItems.filter((i) => i.id !== itemId);
          selectedItems.delete(itemId);

          detectedItems.forEach((item, idx) => {
            item.id = idx;
          });

          // Re-render only the affected page (optimized for mobile)
          await reRenderSinglePage(deletedPageNum, currentFile, detectedItems);

          updateSelectionInfo();
          hideLoading();

          showSuccess("‚úì Watermark removed successfully");

          // Remove processing message if it exists
          const processingMsg = pagesGrid.querySelector(
            ".success-message[style*='f0f9ff']",
          );
          if (processingMsg) {
            processingMsg.remove();
          }
        } catch (error) {
          hideLoading();

          // Remove processing message if it exists
          const processingMsg = pagesGrid.querySelector(
            ".success-message[style*='f0f9ff']",
          );
          if (processingMsg) {
            processingMsg.remove();
          }

          // Show mobile-friendly error
          if (isMobile) {
            errorMsg.classList.add("mobile-error");
          }
          showError("Error: " + error.message);

          // Remove mobile error class after 5 seconds
          if (isMobile) {
            setTimeout(() => {
              errorMsg.classList.remove("mobile-error");
            }, 5000);
          }
        }
      }

      // Re-render only a single page - OPTIMIZED FOR CRISP TEXT
      async function reRenderSinglePage(pageNumber, file, items) {
        try {
          const fileURL = URL.createObjectURL(file);

          const loadingTask = pdfjsLib.getDocument({
            url: fileURL,
            cMapUrl: "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/",
            cMapPacked: true,
            verbosity: 0,
          });

          const pdf = await loadingTask.promise;
          const pageItems = items.filter((item) => item.page === pageNumber);

          const page = await pdf.getPage(pageNumber);
          const viewport = page.getViewport({ scale: 1 });

          // Calculate display scale
          const displayScale = calculateDisplayScale(viewport.width);

          // Update stored scale
          pageRenderScales[pageNumber] = displayScale;

          // Get pixel ratio for crisp rendering
          const pixelRatio = getPixelRatio();

          // Calculate render scale
          let renderScale;
          if (window.innerWidth < 480) {
            renderScale = displayScale * Math.max(1.5, pixelRatio * 0.8);
          } else if (window.innerWidth < 768) {
            renderScale = displayScale * Math.max(1.8, pixelRatio * 0.9);
          } else if (window.innerWidth < 970) {
            renderScale = displayScale * Math.max(2.0, pixelRatio);
          } else {
            renderScale = displayScale * pixelRatio;
          }

          // Round to nearest 0.25 to prevent sub-pixel rendering issues
          renderScale = Math.round(renderScale * 4) / 4;

          const scaledViewport = page.getViewport({ scale: renderScale });

          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d", {
            willReadFrequently: false,
            alpha: false,
          });

          // Set canvas dimensions with proper pixel ratio
          canvas.width = Math.floor(scaledViewport.width);
          canvas.height = Math.floor(scaledViewport.height);

          // Set display dimensions
          const displayWidth = viewport.width * displayScale;
          const displayHeight = viewport.height * displayScale;

          canvas.style.width = displayWidth + "px";
          canvas.style.height = displayHeight + "px";

          // Set CSS image rendering for crisp text
          canvas.style.imageRendering = "-webkit-optimize-contrast";
          canvas.style.imageRendering = "crisp-edges";
          canvas.style.imageRendering = "pixelated";

          // Clear canvas with white background
          context.fillStyle = "white";
          context.fillRect(0, 0, canvas.width, canvas.height);

          // Set rendering hints for better text quality
          context.imageSmoothingEnabled = false;
          context.textDrawingMode = "glyph";
          context.fontKerning = "normal";

          const renderTask = page.render({
            canvasContext: context,
            viewport: scaledViewport,
            intent: "display",
            enableWebGL: false,
            renderInteractiveForms: false,
            imageLayer: true,
            annotationLayer: false,
            renderer: "canvas",
            useWorkerFetch: false,
            isEvalSupported: false,
            enableXfa: false,
          });

          await renderTask.promise;

          const pageCards = pagesGrid.querySelectorAll(".page-card");
          const targetCard = pageCards[pageNumber - 1];

          if (targetCard) {
            const badge = document.createElement("div");
            badge.className = "page-number-badge";
            badge.textContent = `Page ${pageNumber}`;

            const container = document.createElement("div");
            container.className = "page-canvas-container";
            container.style.position = "relative";
            container.style.width = displayWidth + "px";
            container.style.height = displayHeight + "px";
            container.style.margin = "0 auto";
            container.style.overflow = "hidden";
            container.appendChild(canvas);

            pageItems.forEach((item) => {
              const overlay = createOverlay(item, displayScale);
              container.appendChild(overlay);
            });

            targetCard.innerHTML = "";
            targetCard.appendChild(badge);
            targetCard.appendChild(container);
            targetCard.style.maxWidth = displayWidth + "px";
            targetCard.style.width = displayWidth + "px";
          }

          page.cleanup();
          URL.revokeObjectURL(fileURL);
          pdf.destroy();
        } catch (error) {
          console.error(`Error re-rendering page ${pageNumber}:`, error);
          throw error;
        }
      }

      // Add this function to show memory warning
      function showMemoryWarning() {
        const warningDiv = document.createElement("div");
        warningDiv.className = "note-box";
        warningDiv.style.background = "#fef3c7";
        warningDiv.style.borderLeftColor = "#f59e0b";
        warningDiv.style.color = "#92400e";
        warningDiv.innerHTML = `
      ‚ö†Ô∏è <strong>Performance Notice:</strong> Large PDF on mobile device.
      <br>For best results:
      <ul style="margin: 5px 0 0 15px; padding-left: 10px;">
        <li>Try on desktop for faster processing</li>
        <li>Select fewer items at once</li>
        <li>Close other browser tabs</li>
      </ul>
    `;
        pagesGrid.insertBefore(warningDiv, pagesGrid.firstChild);
      }

      // Clear selection
      clearBtn.onclick = () => {
        const selectedOverlays = document.querySelectorAll(
          ".watermark-overlay.selected",
        );

        if (selectedOverlays.length === 0) {
          showError("You haven't selected any items to clear");
          return;
        }

        selectedItems.clear();

        selectedOverlays.forEach((el) => {
          el.classList.remove("selected");
        });

        updateSelectionInfo();
        clearError();
      };

      // Delete selected items in batch
      deleteBtn.onclick = async () => {
        if (selectedItems.size === 0) {
          showError("Please select items to delete first!");
          return;
        }

        showLoading();
        clearError();

        // Mobile optimization - warn if deleting many items
        const isMobile = window.innerWidth <= 768;
        if (isMobile && selectedItems.size > 10) {
          if (
            !confirm(
              `Deleting ${selectedItems.size} items on mobile may be slow. Continue?`,
            )
          ) {
            hideLoading();
            return;
          }
        }

        try {
          const itemsToRemove = Array.from(selectedItems)
            .map((id) => detectedItems.find((i) => i.id === id))
            .filter(Boolean);

          const affectedPages = [
            ...new Set(itemsToRemove.map((item) => item.page)),
          ];

          const formData = new FormData();
          formData.append("files", currentFile);
          formData.append("watermarks", JSON.stringify(itemsToRemove));

          const res = await fetch(REMOVE_URL, {
            method: "POST",
            body: formData,
          });
          if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            throw new Error(
              errorData.error || "Failed to delete selected watermarks",
            );
          }

          const blob = await res.blob();
          currentFile = new File([blob], currentFile.name, {
            type: "application/pdf",
          });

          detectedItems = detectedItems.filter((i) => !selectedItems.has(i.id));

          detectedItems.forEach((item, idx) => {
            item.id = idx;
          });

          // Re-render affected pages one by one (better for mobile)
          for (const pageNum of affectedPages) {
            await reRenderSinglePage(pageNum, currentFile, detectedItems);
            // Small delay between pages on mobile
            if (isMobile) {
              await new Promise((resolve) => setTimeout(resolve, 100));
            }
          }

          selectedItems.clear();
          updateSelectionInfo();
          hideLoading();

          showSuccess(
            `‚úì Deleted ${itemsToRemove.length} watermark${itemsToRemove.length !== 1 ? "s" : ""}`,
          );
        } catch (error) {
          hideLoading();
          showError("Error: " + error.message);
        }
      };

      // Save Changes button
      removeBtn.onclick = () => {
        const url = URL.createObjectURL(currentFile);
        downloadBtn.href = url;
        downloadBtn.download = "cleaned.pdf";
        shareBtn.href = url;

        uploadSection.style.display = "none";
        fileList.style.display = "none";
        pagesGrid.style.display = "none";
        controlPanel.style.display = "none";
        noteBox.style.display = "none";

        resultBtns.style.display = "block";

        const isSmallDevice = window.matchMedia("(max-width: 768px)").matches;

        if (!isSmallDevice) {
          pdfFrame.src = url;
          pdfPreview.style.display = "block";
        }

        fileNameLink.onclick = (e) => {
          e.preventDefault();
          if (isSmallDevice) {
            window.open(url, "_blank");
          } else {
            pdfPreview.scrollIntoView({ behavior: "smooth" });
          }
        };
      };

      // Reset page
      resetBtn.onclick = () => {
        resetApplication();
      };

      // Handle window resize to maintain proper overlay positioning
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(async () => {
          if (currentFile && detectedItems.length > 0) {
            // Re-render all pages with new scale
            await renderPDFWithOverlays(currentFile, detectedItems);
            updateSelectionInfo();
          }
        }, 500);
      });
    </script>
  </body>
</html>
