<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFMaster - Document Scanner</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .container { max-width: 900px; margin: 0 auto; padding: 20px; }
        header { background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 15px 0; margin-bottom: 30px; }
        .logo { font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 24px; color: white; text-align: center; }
        .card { background: white; border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); margin-bottom: 20px; }
        h1 { font-family: 'Montserrat', sans-serif; color: #333; margin-bottom: 10px; }
        .subtitle { color: #666; margin-bottom: 25px; }
        #camera, #canvas { width: 100%; border-radius: 12px; display: block; }
        #canvas { position: relative; cursor: crosshair; }
        .canvas-wrapper { position: relative; display: inline-block; width: 100%; }
        .corner-handle { position: absolute; width: 20px; height: 20px; background: #667eea; border: 3px solid white; border-radius: 50%; cursor: grab; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 10; transform: translate(-50%, -50%); }
        .corner-handle:active { cursor: grabbing; background: #764ba2; }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px; }
        button { padding: 12px 24px; border: none; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.3s; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; }
        button i { font-size: 16px; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn-secondary { background: #f0f0f0; color: #333; }
        .btn-secondary:hover { background: #e0e0e0; }
        .btn-success { background: #10b981; color: white; }
        .btn-success:hover { background: #059669; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .hidden { display: none !important; }
        .mode-info { background: #f0f9ff; border-left: 4px solid #667eea; padding: 12px; border-radius: 8px; margin: 15px 0; color: #334155; }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .feature-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; text-align: center; font-weight: 500; }
        footer { text-align: center; color: white; padding: 20px; font-size: 14px; }
        #previewImage { width: 100%; border-radius: 12px; margin-top: 15px; }
        .controls { background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 15px 0; }
        .control-row { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
        .control-row label { min-width: 100px; font-weight: 500; color: #555; }
        input[type="range"] { flex: 1; }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">üìÑ PDFMaster Scanner</div>
        </div>
    </header>

    <div class="container">
        <div class="card">
            <h1>Document Scanner</h1>
            <p class="subtitle">Scan documents with auto-detection and manual cropping</p>

            <div id="cameraSection">
                <video id="camera" autoplay playsinline></video>
                <div class="btn-group">
                    <button id="startCamera" class="btn-primary">
                        <i class="fa fa-camera"></i> Open Camera
                    </button>
                    <button id="uploadImage" class="btn-secondary">
                        <i class="fa fa-upload"></i> Upload Image
                    </button>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>
            </div>

            <div id="captureSection" class="hidden">
                <div class="btn-group">
                    <button id="capture" class="btn-primary">
                        <i class="fa fa-circle"></i> Capture Photo
                    </button>
                    <button id="cancelCamera" class="btn-secondary">
                        <i class="fa fa-times"></i> Cancel
                    </button>
                </div>
            </div>

            <div id="cropSection" class="hidden">
                <div class="mode-info">
                    <strong>üìê Crop Mode:</strong> Drag the corner points to adjust the document boundary. Click "Auto Detect" to reset.
                </div>
                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                    <div id="cornerTL" class="corner-handle" style="top: 0; left: 0;"></div>
                    <div id="cornerTR" class="corner-handle" style="top: 0; right: 0;"></div>
                    <div id="cornerBR" class="corner-handle" style="bottom: 0; right: 0;"></div>
                    <div id="cornerBL" class="corner-handle" style="bottom: 0; left: 0;"></div>
                </div>
                <div class="btn-group">
                    <button id="autoDetect" class="btn-primary">
                        <i class="fa fa-magic"></i> Auto Detect
                    </button>
                    <button id="applyCrop" class="btn-success">
                        <i class="fa fa-crop"></i> Apply Crop
                    </button>
                    <button id="resetCrop" class="btn-danger">
                        <i class="fa fa-rotate-left"></i> Start Over
                    </button>
                </div>
            </div>

            <div id="enhanceSection" class="hidden">
                <img id="previewImage" alt="Scanned document">
                
                <div class="controls">
                    <h3 style="margin-bottom: 15px;">Enhance Document</h3>
                    <div class="control-row">
                        <label>Brightness:</label>
                        <input type="range" id="brightness" min="-50" max="50" value="0">
                        <span id="brightnessVal">0</span>
                    </div>
                    <div class="control-row">
                        <label>Contrast:</label>
                        <input type="range" id="contrast" min="-50" max="50" value="0">
                        <span id="contrastVal">0</span>
                    </div>
                </div>

                <div class="btn-group">
                    <button id="enhanceBW" class="btn-secondary">
                        <i class="fa fa-adjust"></i> Black & White
                    </button>
                    <button id="enhanceColor" class="btn-secondary">
                        <i class="fa fa-palette"></i> Color Mode
                    </button>
                    <button id="downloadJpg" class="btn-success">
                        <i class="fa fa-image"></i> Download JPG
                    </button>
                    <button id="downloadPdf" class="btn-success">
                        <i class="fa fa-file-pdf"></i> Download PDF
                    </button>
                    <button id="scanAnother" class="btn-secondary">
                        <i class="fa fa-camera"></i> Scan Another
                    </button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 20px;">Features</h2>
            <div class="feature-grid">
                <div class="feature-card">üì∏ Auto Edge Detection</div>
                <div class="feature-card">‚úÇÔ∏è Manual Cropping</div>
                <div class="feature-card">üé® Image Enhancement</div>
                <div class="feature-card">üìÑ PDF Export</div>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2026 PDFMaster. All rights reserved.</p>
    </footer>

    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script>
        const video = document.getElementById("camera");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const preview = document.getElementById("previewImage");
        
        let stream = null;
        let corners = { tl: {x: 0, y: 0}, tr: {x: 0, y: 0}, br: {x: 0, y: 0}, bl: {x: 0, y: 0} };
        let originalImage = null;
        let croppedImage = null;

        // Camera Controls
        document.getElementById("startCamera").onclick = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: 1920, height: 1080 } 
                });
                video.srcObject = stream;
                document.getElementById("cameraSection").classList.add("hidden");
                document.getElementById("captureSection").classList.remove("hidden");
                video.style.display = "block";
            } catch (err) {
                alert("Camera access denied: " + err.message);
            }
        };

        document.getElementById("uploadImage").onclick = () => {
            document.getElementById("fileInput").click();
        };

        document.getElementById("fileInput").onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        originalImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        showCropSection();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        };

        document.getElementById("capture").onclick = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            originalImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            showCropSection();
        };

        document.getElementById("cancelCamera").onclick = () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            document.getElementById("cameraSection").classList.remove("hidden");
            document.getElementById("captureSection").classList.add("hidden");
            video.style.display = "none";
        };

        function showCropSection() {
            document.getElementById("cameraSection").classList.add("hidden");
            document.getElementById("captureSection").classList.add("hidden");
            document.getElementById("cropSection").classList.remove("hidden");
            video.style.display = "none";
            
            detectDocumentEdges();
            updateCornerHandles();
            drawCropOverlay();
        }

        function detectDocumentEdges() {
            if (typeof cv === 'undefined') {
                // Fallback if OpenCV not loaded
                corners = {
                    tl: { x: canvas.width * 0.1, y: canvas.height * 0.1 },
                    tr: { x: canvas.width * 0.9, y: canvas.height * 0.1 },
                    br: { x: canvas.width * 0.9, y: canvas.height * 0.9 },
                    bl: { x: canvas.width * 0.1, y: canvas.height * 0.9 }
                };
                return;
            }

            let src = cv.imread(canvas);
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let edges = new cv.Mat();

            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
            cv.Canny(blurred, edges, 75, 200);

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

            let maxArea = 0;
            let bestContour = null;

            for (let i = 0; i < contours.size(); i++) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                if (approx.rows === 4 && area > maxArea && area > (canvas.width * canvas.height * 0.1)) {
                    maxArea = area;
                    bestContour = approx;
                }
                approx.delete();
            }

            if (bestContour) {
                const pts = [];
                for (let i = 0; i < 4; i++) {
                    pts.push({ x: bestContour.data32S[i * 2], y: bestContour.data32S[i * 2 + 1] });
                }
                
                // Sort points: top-left, top-right, bottom-right, bottom-left
                pts.sort((a, b) => a.y - b.y);
                const top = pts.slice(0, 2).sort((a, b) => a.x - b.x);
                const bottom = pts.slice(2, 4).sort((a, b) => a.x - b.x);
                
                corners = {
                    tl: top[0],
                    tr: top[1],
                    br: bottom[1],
                    bl: bottom[0]
                };
            } else {
                // Default corners
                corners = {
                    tl: { x: canvas.width * 0.1, y: canvas.height * 0.1 },
                    tr: { x: canvas.width * 0.9, y: canvas.height * 0.1 },
                    br: { x: canvas.width * 0.9, y: canvas.height * 0.9 },
                    bl: { x: canvas.width * 0.1, y: canvas.height * 0.9 }
                };
            }

            src.delete(); gray.delete(); blurred.delete(); edges.delete();
            contours.delete(); hierarchy.delete();
        }

        function drawCropOverlay() {
            ctx.putImageData(originalImage, 0, 0);
            
            // Draw overlay
            ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw document area
            ctx.globalCompositeOperation = "destination-out";
            ctx.beginPath();
            ctx.moveTo(corners.tl.x, corners.tl.y);
            ctx.lineTo(corners.tr.x, corners.tr.y);
            ctx.lineTo(corners.br.x, corners.br.y);
            ctx.lineTo(corners.bl.x, corners.bl.y);
            ctx.closePath();
            ctx.fill();
            
            ctx.globalCompositeOperation = "source-over";
            
            // Draw border
            ctx.strokeStyle = "#667eea";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(corners.tl.x, corners.tl.y);
            ctx.lineTo(corners.tr.x, corners.tr.y);
            ctx.lineTo(corners.br.x, corners.br.y);
            ctx.lineTo(corners.bl.x, corners.bl.y);
            ctx.closePath();
            ctx.stroke();
        }

        function updateCornerHandles() {
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            
            document.getElementById("cornerTL").style.left = (corners.tl.x * scaleX) + "px";
            document.getElementById("cornerTL").style.top = (corners.tl.y * scaleY) + "px";
            
            document.getElementById("cornerTR").style.left = (corners.tr.x * scaleX) + "px";
            document.getElementById("cornerTR").style.top = (corners.tr.y * scaleY) + "px";
            
            document.getElementById("cornerBR").style.left = (corners.br.x * scaleX) + "px";
            document.getElementById("cornerBR").style.top = (corners.br.y * scaleY) + "px";
            
            document.getElementById("cornerBL").style.left = (corners.bl.x * scaleX) + "px";
            document.getElementById("cornerBL").style.top = (corners.bl.y * scaleY) + "px";
        }

        // Draggable corners
        ["TL", "TR", "BR", "BL"].forEach(corner => {
            const handle = document.getElementById("corner" + corner);
            let isDragging = false;
            
            handle.onmousedown = handle.ontouchstart = (e) => {
                isDragging = true;
                e.preventDefault();
            };
            
            document.onmousemove = document.ontouchmove = (e) => {
                if (!isDragging || handle !== document.querySelector(".corner-handle:active")) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const x = (clientX - rect.left) * scaleX;
                const y = (clientY - rect.top) * scaleY;
                
                corners[corner.toLowerCase()] = { 
                    x: Math.max(0, Math.min(canvas.width, x)), 
                    y: Math.max(0, Math.min(canvas.height, y)) 
                };
                
                updateCornerHandles();
                drawCropOverlay();
            };
            
            document.onmouseup = document.ontouchend = () => {
                isDragging = false;
            };
        });

        document.getElementById("autoDetect").onclick = () => {
            detectDocumentEdges();
            updateCornerHandles();
            drawCropOverlay();
        };

        document.getElementById("applyCrop").onclick = () => {
            applyPerspectiveTransform();
        };

        function applyPerspectiveTransform() {
            if (typeof cv === 'undefined') {
                alert("OpenCV is still loading. Please wait a moment and try again.");
                return;
            }

            let src = cv.imread(canvas);
            
            // Calculate destination size
            const widthTop = Math.sqrt(Math.pow(corners.tr.x - corners.tl.x, 2) + Math.pow(corners.tr.y - corners.tl.y, 2));
            const widthBottom = Math.sqrt(Math.pow(corners.br.x - corners.bl.x, 2) + Math.pow(corners.br.y - corners.bl.y, 2));
            const heightLeft = Math.sqrt(Math.pow(corners.bl.x - corners.tl.x, 2) + Math.pow(corners.bl.y - corners.tl.y, 2));
            const heightRight = Math.sqrt(Math.pow(corners.br.x - corners.tr.x, 2) + Math.pow(corners.br.y - corners.tr.y, 2));
            
            const maxWidth = Math.max(widthTop, widthBottom);
            const maxHeight = Math.max(heightLeft, heightRight);
            
            const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                corners.tl.x, corners.tl.y,
                corners.tr.x, corners.tr.y,
                corners.br.x, corners.br.y,
                corners.bl.x, corners.bl.y
            ]);
            
            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                maxWidth, 0,
                maxWidth, maxHeight,
                0, maxHeight
            ]);
            
            const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
            let dst = new cv.Mat();
            cv.warpPerspective(src, dst, M, new cv.Size(maxWidth, maxHeight));
            
            canvas.width = maxWidth;
            canvas.height = maxHeight;
            cv.imshow(canvas, dst);
            
            croppedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            preview.src = canvas.toDataURL("image/jpeg", 0.95);
            
            src.delete(); dst.delete(); M.delete(); srcPoints.delete(); dstPoints.delete();
            
            document.getElementById("cropSection").classList.add("hidden");
            document.getElementById("enhanceSection").classList.remove("hidden");
        };

        document.getElementById("resetCrop").onclick = () => {
            document.getElementById("cropSection").classList.add("hidden");
            document.getElementById("cameraSection").classList.remove("hidden");
        };

        // Enhancement controls
        document.getElementById("brightness").oninput = (e) => {
            document.getElementById("brightnessVal").textContent = e.target.value;
            applyFilters();
        };

        document.getElementById("contrast").oninput = (e) => {
            document.getElementById("contrastVal").textContent = e.target.value;
            applyFilters();
        };

        function applyFilters() {
            if (!croppedImage) return;
            
            ctx.putImageData(croppedImage, 0, 0);
            const brightness = parseInt(document.getElementById("brightness").value);
            const contrast = parseInt(document.getElementById("contrast").value);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = factor * (data[i] - 128) + 128 + brightness;
                data[i + 1] = factor * (data[i + 1] - 128) + 128 + brightness;
                data[i + 2] = factor * (data[i + 2] - 128) + 128 + brightness;
            }
            
            ctx.putImageData(imageData, 0, 0);
            preview.src = canvas.toDataURL("image/jpeg", 0.95);
        }

        document.getElementById("enhanceBW").onclick = () => {
            if (typeof cv === 'undefined') return;
            
            let src = cv.imread(canvas);
            let gray = new cv.Mat();
            let bw = new cv.Mat();
            
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.adaptiveThreshold(gray, bw, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            
            cv.imshow(canvas, bw);
            preview.src = canvas.toDataURL("image/jpeg", 0.95);
            
            src.delete(); gray.delete(); bw.delete();
        };

        document.getElementById("enhanceColor").onclick = () => {
            ctx.putImageData(croppedImage, 0, 0);
            preview.src = canvas.toDataURL("image/jpeg", 0.95);
        };

        document.getElementById("downloadJpg").onclick = () => {
            const a = document.createElement("a");
            a.href = preview.src;
            a.download = "scanned-" + Date.now() + ".jpg";
            a.click();
        };

        document.getElementById("downloadPdf").onclick = async () => {
            const pdfDoc = await PDFLib.PDFDocument.create();
            const img = await pdfDoc.embedJpg(preview.src);
            const page = pdfDoc.addPage([img.width, img.height]);
            page.drawImage(img, { x: 0, y: 0, width: img.width, height: img.height });
            const bytes = await pdfDoc.save();
            const blob = new Blob([bytes], { type: "application/pdf" });
            
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "scanned-" + Date.now() + ".pdf";
            a.click();
        };

        document.getElementById("scanAnother").onclick = () => {
            document.getElementById("enhanceSection").classList.add("hidden");
            document.getElementById("cameraSection").classList.remove("hidden");
            document.getElementById("brightness").value = 0;
            document.getElementById("contrast").value = 0;
            document.getElementById("brightnessVal").textContent = "0";
            document.getElementById("contrastVal").textContent = "0";
        };
    </script>
</body>
</html>