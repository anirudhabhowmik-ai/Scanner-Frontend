<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Add Watermark to PDF | PDFMaster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Inter:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="icon" href="./favicon.ico">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <style>
        .pages-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            border: 2px dashed #e5e7eb;
        }

        @media(max-width:1024px) {
            .pages-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media(max-width:600px) {
            .pages-grid {
                grid-template-columns: 1fr;
            }
        }

        .page-card {
            position: relative;
            overflow: visible;
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .page-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .page-card.out-of-range {
            opacity: 0.4;
        }

        .page-card canvas {
            width: 100%;
            border-radius: 8px;
            position: relative;
        }

        .page-number-badge {
            position: absolute;
            top: -8px;
            left: 8px;
            background: #4f46e5;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            z-index: 5;
        }

        .watermark-preview {
            position: absolute;
            cursor: move;
            font-weight: bold;
            user-select: none;
            white-space: nowrap;
            z-index: 10;
            line-height: 0;
        }

        .watermark-preview img {
            pointer-events: none;
            display: block;
        }

        .watermark-preview.has-image {
            border: 2px dashed #4f46e5;
            padding: 5px;
            background: rgba(79, 70, 229, 0.05);
        }

        .watermark-preview .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4f46e5;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: all;
            z-index: 20;
        }

        .resize-handle-tl {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }

        .resize-handle-tr {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }

        .resize-handle-bl {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }

        .resize-handle-br {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }

        .page-apply-btn {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: #f59e0b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 11px;
            transition: all 0.2s;
            display: none;
            z-index: 50;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        .page-apply-btn:hover {
            background: #d97706;
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 16px rgba(245, 158, 11, 0.5);
        }

        .page-apply-btn.show {
            display: block;
        }

        .note-box {
            background: #f0f9ff;
            border-left: 4px solid #3b82f6;
            padding: 12px 16px;
            margin-top: 15px;
            font-size: 14px;
            border-radius: 4px;
        }

        .file-list i {
            color: red;
            cursor: pointer;
            margin-left: 8px;
        }

        #wmOptions label {
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 4px;
            display: block;
            color: #1e3a8a;
            font-size: 11px;
        }

        /* ===== STICKY CONTROLS AT BOTTOM ===== */
        #wmOptions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 3px solid #4f46e5;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-height: 180px;
            overflow-y: auto;
            padding: 8px 12px 10px;
            display: none;
            transition: max-height 0.3s ease;
        }

        #wmOptions.show {
            display: block;
        }

        .options-container {
            max-width: 1600px;
            margin: 0 auto;
            text-align: left;
        }

        .watermark-type-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e5e7eb;
        }

        .watermark-type-row>label {
            font-size: 12px;
            font-weight: 700;
            color: #1e3a8a;
            margin: 0;
        }

        #textControls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: flex-end;
            margin-bottom: 8px;
        }

        #textControls>div {
            display: flex;
            flex-direction: column;
        }

        #textControls input[type="text"] {
            padding: 5px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            min-width: 180px;
        }

        .text-style-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 0;
        }

        .option-group {
            display: flex;
            flex-direction: column;
        }

        .option-group input,
        .option-group select {
            padding: 5px 7px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            transition: border-color 0.2s;
        }

        .option-group input:focus,
        .option-group select:focus {
            outline: none;
            border-color: #4f46e5;
        }

        .color-input-wrapper {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .color-input-wrapper input[type="color"] {
            width: 35px;
            height: 28px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            padding: 2px;
        }

        .color-input-wrapper input[type="text"] {
            width: 70px;
            padding: 5px 6px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 11px;
        }

        .text-style-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }

        .text-style-buttons button {
            padding: 5px 9px;
            border: 1px solid #e5e7eb;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .text-style-buttons button.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        .text-style-buttons button:hover {
            border-color: #4f46e5;
        }

        .text-style-buttons .option-group {
            min-width: 90px;
        }

        .text-style-buttons .option-group select,
        .text-style-buttons .option-group input {
            padding: 5px 6px;
            font-size: 12px;
        }

        .radio-group {
            display: flex;
            gap: 12px;
            margin: 0;
            flex-wrap: wrap;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            color: #374151;
            font-size: 12px;
        }

        .radio-group input[type="radio"] {
            cursor: pointer;
        }

        .page-range-input {
            display: flex;
            gap: 5px;
        }

        .page-range-input input {
            flex: 1;
            padding: 5px 6px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
        }

        #imageControls input[type="file"] {
            padding: 5px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .success-message {
            background: #d1fae5;
            border-left: 4px solid #059669;
            padding: 12px 16px;
            margin-top: 15px;
            font-size: 14px;
            border-radius: 4px;
            color: #065f46;
            display: none;
        }

        .success-message.show {
            display: block;
        }

        .result-btns-container {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn-loading .btn-spinner {
            display: inline-block;
            margin-right: 8px;
        }

        .btn-spinner {
            display: none;
        }

        /* Scrollbar styling for options panel */
        #wmOptions::-webkit-scrollbar {
            width: 5px;
        }

        #wmOptions::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        #wmOptions::-webkit-scrollbar-thumb {
            background: #4f46e5;
            border-radius: 4px;
        }

        #wmOptions::-webkit-scrollbar-thumb:hover {
            background: #4338ca;
        }

        .watermark-preview {
            touch-action: none;
        }

        .resize-handle {
            touch-action: none;
        }

        /* Responsive breakpoints */
        @media(max-width:1400px) {
            .options-grid {
                grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            }
        }

        @media(max-width:1200px) {
            #wmOptions {
                max-height: 200px;
            }

            .options-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            #textControls input[type="text"] {
                min-width: 150px;
            }
        }

        @media(max-width:900px) {
            #wmOptions {
                max-height: 220px;
            }

            .options-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            #textControls {
                flex-direction: column;
                align-items: stretch;
            }

            .text-style-row {
                width: 100%;
            }
        }

        @media(max-width:768px) {
            #wmOptions {
                max-height: 250px;
                padding: 8px 10px;
            }

            .watermark-type-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
            }

            .options-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }

            .result-btns-container {
                flex-direction: column;
            }

            .text-style-buttons .option-group {
                min-width: 75px;
            }
        }

        @media(max-width:600px) {
            #wmOptions {
                max-height: 260px;
                padding: 6px 8px;
            }

            #wmOptions label {
                font-size: 10px;
            }

            .watermark-type-row>label {
                font-size: 11px;
            }

            .option-group input,
            .option-group select {
                font-size: 11px;
                padding: 4px 6px;
            }

            .radio-group label {
                font-size: 11px;
            }

            .text-style-buttons button {
                padding: 4px 8px;
                font-size: 11px;
            }

            .text-style-buttons .option-group select,
            .text-style-buttons .option-group input {
                font-size: 11px;
            }

            #textControls input[type="text"] {
                font-size: 11px;
                padding: 4px 6px;
            }

            .color-input-wrapper input[type="text"] {
                font-size: 10px;
                width: 65px;
            }

            .options-grid {
                gap: 5px;
            }
        }

        @media(max-width:480px) {
            #wmOptions {
                max-height: 150px;
            }

            .text-style-buttons {
                gap: 4px;
            }

            .text-style-buttons .option-group {
                min-width: auto;
            }

            .page-range-input {
                gap: 4px;
            }

            .page-range-input input {
                width: 40px;
            }
        }
    </style>
</head>

<body>
    <section id="header-placeholder"></section>

    <section class="merge-tool">
        <div class="container">

            <h1>Add Watermark</h1>
            <p>Add watermark to multiple PDFs with custom positioning and styling.</p>

            <div class="upload-section">

                <div id="uploadSection">
                    <label class="upload-label" for="pdfUpload"><i class="fa fa-upload"></i> Choose PDF files</label>
                    <input type="file" id="pdfUpload" accept=".pdf" multiple>
                </div>

                <div class="success-message" id="successMsg"></div>

                <ul id="fileList" class="file-list" style="display:none;"></ul>
                <div id="pagesGrid" class="pages-grid" style="display:none;"></div>

                <!-- OPTIONS -->
                <div id="wmOptions" style="display:none; text-align: left;">

                    <label>Watermark Type</label>
                    <div class="radio-group">
                        <label style="display: flex; align-items: center;"><input type="radio" name="wmType"
                                value="text" checked style="margin-top: 0;"> Text</label>
                        <label style="display: flex; align-items: center;"><input type="radio" name="wmType"
                                value="image" style="margin-top: 0;"> Image</label>
                    </div>

                    <div id="textControls" style="display: flex; gap: 10px;">
                        <div style="margin-bottom: 5px;">
                            <label>Watermark Text</label>
                            <input type="text" id="wmText" placeholder="Enter watermark text"
                                style="padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 6px;">
                        </div>

                        <div>
                            <label>Text Styling</label>
                            <div class="text-style-buttons">
                                <!-- Font Family -->
                                <div class="option-group" id="fontFamilyGroup">
                                    <select id="fontFamily">
                                        <option value="Helvetica">Helvetica</option>
                                        <option value="Helvetica-Bold">Helvetica Bold</option>
                                        <option value="Courier">Courier</option>
                                        <option value="Times-Roman">Times Roman</option>
                                    </select>
                                </div>
                                <!-- Font Size -->
                                <div class="option-group" id="fontSizeGroup">
                                    <input type="number" id="fontSize" value="36" min="8" max="200">
                                </div>

                                <!-- Font color -->
                                <div class="color-input-wrapper">
                                    <input type="color" id="textColor" value="#000000">
                                    <input type="text" id="textColorHex" value="#000000" placeholder="#000000">
                                </div>

                                <button type="button" id="boldBtn" title="Bold"><i class="fa fa-bold"></i></button>
                                <button type="button" id="italicBtn" title="Italic"><i
                                        class="fa fa-italic"></i></button>
                                <button type="button" id="underlineBtn" title="Underline"><i
                                        class="fa fa-underline"></i></button>
                            </div>
                        </div>
                    </div>

                    <div id="imageControls" style="display:none;">
                        <label>Watermark Image</label>
                        <input type="file" id="wmImage" accept="image/*"
                            style="padding: 10px; border: 1px solid #e5e7eb; border-radius: 6px;">
                    </div>

                    <div class="options-grid">
                        <div class="option-group">
                            <label>Opacity</label>
                            <input type="number" id="opacity" step="0.1" min="0.1" max="1" value="0.3">
                        </div>

                        <div class="option-group">
                            <label>Rotation (degrees)</label>
                            <input type="number" id="rotation" value="0" min="-180" max="180" step="15">
                        </div>

                        <div class="option-group">
                            <label>Position</label>
                            <select id="position">
                                <option value="center">Center</option>
                                <option value="top-left">Top Left</option>
                                <option value="top-right">Top Right</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="bottom-right">Bottom Right</option>
                            </select>
                        </div>

                        <div class="option-group">
                            <label>Page Range</label>
                            <div class="page-range-input">
                                <input type="number" id="pageStart" value="1" min="1" placeholder="Start">
                                <input type="number" id="pageEnd" value="0" min="0" placeholder="End (0=all)">
                            </div>
                        </div>
                    </div>

                </div>

                <button id="watermarkBtn" class="cta-button" style="margin-top:15px;">
                    <span class="btn-spinner">
                        <i class="fa fa-spinner fa-spin"></i>
                    </span>
                    <span class="btn-text"><i class="fa fa-stamp"></i></span> Add Watermark
                </button>

                <p class="error-text" id="errorMsg"></p>
                <div class="note-box">
                    ðŸ’¡ Drag watermarks to reposition and resize images. Each modified page will show an "Apply to All"
                    button.
                </div>

                <div id="resultBtns" style="display:none; margin-top:30px;">
                    <div class="result-card">
                        <i class="fa fa-file-pdf"></i>
                    </div>

                    <p class="file-name">
                        <a href="#" id="fileNameLink">watermarked.pdf</a>
                    </p>

                    <div class="result-btns-container">
                        <a id="downloadBtn" href="#" class="cta-button">
                            <i class="fa fa-download"></i> Download
                        </a>
                        <a id="shareBtn" href="#" class="cta-button">
                            <i class="fa fa-share-alt"></i> Share
                        </a>
                        <button id="resetBtn" class="secondary-btn">
                            <i class="fa fa-rotate-right"></i> Add Another Watermark
                        </button>
                    </div>
                </div>

            </div>

            <div id="pdfPreview" style="display:none; margin-top:30px;">
                <h4>Preview Watermarked PDF</h4>
                <iframe id="pdfFrame" width="100%" height="600"
                    style="border-radius:12px; border:1px solid #e5e7eb;"></iframe>
            </div>

        </div>
    </section>

    <section id="footer-placeholder"></section>
    <script src="./js/app.js"></script>

    <script>
        const BACKEND_URL = `${BACKEND_BASE_URL}/add-watermark`;
        const pdfUpload = document.getElementById("pdfUpload");
        const fileList = document.getElementById("fileList");
        const pagesGrid = document.getElementById("pagesGrid");
        const wmOptions = document.getElementById("wmOptions");
        const errorMsg = document.getElementById("errorMsg");
        const successMsg = document.getElementById("successMsg");
        const watermarkBtn = document.getElementById("watermarkBtn");
        const uploadSection = document.getElementById("uploadSection");
        const resultBtns = document.getElementById("resultBtns");
        const downloadBtn = document.getElementById("downloadBtn");
        const shareBtn = document.getElementById("shareBtn");
        const resetBtn = document.getElementById("resetBtn");
        const pdfPreview = document.getElementById("pdfPreview");
        const pdfFrame = document.getElementById("pdfFrame");
        const fileNameLink = document.getElementById("fileNameLink");

        const wmText = document.getElementById("wmText");
        const wmImage = document.getElementById("wmImage");
        const fontSize = document.getElementById("fontSize");
        const opacity = document.getElementById("opacity");
        const position = document.getElementById("position");
        const rotation = document.getElementById("rotation");
        const fontFamily = document.getElementById("fontFamily");
        const pageStart = document.getElementById("pageStart");
        const pageEnd = document.getElementById("pageEnd");
        const textColor = document.getElementById("textColor");
        const textColorHex = document.getElementById("textColorHex");

        const boldBtn = document.getElementById("boldBtn");
        const italicBtn = document.getElementById("italicBtn");
        const underlineBtn = document.getElementById("underlineBtn");

        const fontSizeGroup = document.getElementById("fontSizeGroup");
        const fontFamilyGroup = document.getElementById("fontFamilyGroup");

        let files = [];
        let watermarkData = {
            bold: false,
            italic: false,
            underline: false
        };
        let totalPagesCount = 0;

        pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

        /* ===== DEBOUNCE HELPER ===== */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        /* ===== COLOR SYNC ===== */
        textColor.oninput = () => {
            textColorHex.value = textColor.value.toUpperCase();
            updatePreview();
        };

        textColorHex.oninput = () => {
            const hex = textColorHex.value;
            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                textColor.value = hex;
                updatePreview();
            }
        };

        /* ===== ERROR & SUCCESS ===== */
        function showError(msg) {
            errorMsg.textContent = msg;
            errorMsg.style.display = "block";
            successMsg.classList.remove("show");
        }

        function clearError() {
            errorMsg.textContent = "";
            errorMsg.style.display = "none";
        }

        function showSuccess(msg) {
            successMsg.textContent = msg;
            successMsg.classList.add("show");
            clearError();
            setTimeout(() => successMsg.classList.remove("show"), 3000);
        }

        /* ===== RADIO FIX - Hide font controls for images ===== */
        document.querySelectorAll("input[name='wmType']").forEach(r => {
            r.onchange = () => {
                clearError()
                const isText = r.value === "text";
                document.getElementById("textControls").style.display = isText ? "block" : "none";
                document.getElementById("imageControls").style.display = isText ? "none" : "block";
                updatePreview();
            };
        });

        /* ===== TEXT STYLE BUTTONS ===== */
        boldBtn.onclick = () => {
            watermarkData.bold = !watermarkData.bold;
            boldBtn.classList.toggle("active", watermarkData.bold);
            updatePreview();
        };

        italicBtn.onclick = () => {
            watermarkData.italic = !watermarkData.italic;
            italicBtn.classList.toggle("active", watermarkData.italic);
            updatePreview();
        };

        underlineBtn.onclick = () => {
            watermarkData.underline = !watermarkData.underline;
            underlineBtn.classList.toggle("active", watermarkData.underline);
            updatePreview();
        };

        /* ===== UPLOAD (NO DUPLICATES) ===== */
        pdfUpload.onchange = e => {
            clearError();
            const newFiles = [...e.target.files];
            newFiles.forEach(f => {
                if (!files.some(x => x.name === f.name && x.size === f.size)) files.push(f);
            });
            renderFileList();
            loadAllPDFs();
        };

        /* ===== FILE LIST + DELETE FIX ===== */
        function renderFileList() {
            if (files.length === 0) {
                fileList.style.display = "none";
                pagesGrid.style.display = "none";
                wmOptions.style.display = "none";
                return;
            }
            fileList.style.display = "block";
            fileList.innerHTML = "";
            files.forEach((f, i) => {
                const li = document.createElement("li");
                li.innerHTML = `<i class="fa fa-file-pdf pdf-icon"></i> <span>${f.name}</span> <i class="fa fa-times delete-file"></i>`;
                li.querySelector(".delete-file").onclick = () => {
                    files.splice(i, 1);
                    renderFileList();
                    loadAllPDFs();
                };
                fileList.appendChild(li);
            });
        }

        /* ===== LOAD PDF PAGES ===== */
        async function loadAllPDFs() {
            pagesGrid.innerHTML = "";
            if (files.length === 0) return;

            pagesGrid.style.display = "grid";
            wmOptions.style.display = "block";
            totalPagesCount = 0;

            for (let file of files) {
                const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
                for (let i = 1; i <= pdf.numPages; i++) {
                    totalPagesCount++;
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1 });
                    const canvas = document.createElement("canvas");
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    await page.render({ canvasContext: canvas.getContext("2d"), viewport }).promise;

                    const card = document.createElement("div");
                    card.className = "page-card";
                    card.dataset.pageNum = totalPagesCount;

                    // Add page number badge
                    const badge = document.createElement("div");
                    badge.className = "page-number-badge";
                    badge.textContent = `Page ${totalPagesCount}`;
                    card.appendChild(badge);

                    card.appendChild(canvas);

                    // Add "Apply to All" button for this page
                    const applyBtn = document.createElement("button");
                    applyBtn.className = "page-apply-btn";
                    applyBtn.innerHTML = '<i class="fa fa-clone"></i> Apply to All';
                    applyBtn.onclick = () => applyThisPageToAll(card);
                    card.appendChild(applyBtn);

                    pagesGrid.appendChild(card);
                }
            }
            updatePageRangeDisplay();
            updatePreview();
        }

        /* ===== UPDATE PAGE RANGE DISPLAY ===== */
        function updatePageRangeDisplay() {
            const start = parseInt(pageStart.value) || 1;
            const end = parseInt(pageEnd.value) || totalPagesCount;
            const effectiveEnd = end === 0 ? totalPagesCount : Math.min(end, totalPagesCount);

            document.querySelectorAll(".page-card").forEach(card => {
                const pageNum = parseInt(card.dataset.pageNum);
                if (pageNum < start || pageNum > effectiveEnd) {
                    card.classList.add("out-of-range");
                } else {
                    card.classList.remove("out-of-range");
                }
            });

            // Update preview to remove watermarks from out-of-range pages
            updatePreview();
        }

        function getPreviewFont(pdfFont) {
            const map = {
                "Helvetica": "Arial, sans-serif",
                "Helvetica-Bold": "Arial Black, Arial, sans-serif",
                "Courier": "Courier New, monospace",
                "Times-Roman": "Times New Roman, serif"
            };
            return map[pdfFont] || "Arial, sans-serif";
        }

        /* ===== HELPER: GET WATERMARK DIMENSIONS (accounting for rotation) ===== */
        function getWatermarkDimensions(el) {
            // Temporarily measure the element without rotation to get base dimensions
            const currentTransform = el.style.transform;
            el.style.transform = 'translate(-50%, -50%)'; // Remove rotation temporarily

            const rect = el.getBoundingClientRect();
            const baseWidth = rect.width;
            const baseHeight = rect.height;

            // Restore original transform
            el.style.transform = currentTransform;

            // Calculate rotated bounding box dimensions
            const rotationRad = (parseFloat(rotation.value) || 0) * Math.PI / 180;
            const cos = Math.abs(Math.cos(rotationRad));
            const sin = Math.abs(Math.sin(rotationRad));

            const rotatedWidth = baseWidth * cos + baseHeight * sin;
            const rotatedHeight = baseWidth * sin + baseHeight * cos;

            return {
                width: rotatedWidth,
                height: rotatedHeight,
                baseWidth: baseWidth,
                baseHeight: baseHeight
            };
        }

        /* ===== PREVIEW WITH PROPER DIMENSION CALCULATION ===== */
        function updatePreview() {
            clearError();
            const type = document.querySelector("input[name='wmType']:checked").value;

            document.querySelectorAll(".page-card").forEach(card => {
                const old = card.querySelector(".watermark-preview");
                if (old) old.remove();

                // Don't add watermark to out-of-range pages
                if (card.classList.contains("out-of-range")) {
                    return;
                }

                const canvas = card.querySelector("canvas");
                const wm = document.createElement("div");
                wm.className = "watermark-preview";
                wm.style.opacity = opacity.value;
                wm.style.fontSize = fontSize.value + "px";

                const rotationTransform = `rotate(${rotation.value}deg)`;

                // First, add content to watermark so we can measure it
                if (type === "image") {
                    if (!wmImage.files[0]) return;
                    wm.classList.add("has-image");
                    const img = document.createElement("img");
                    img.src = URL.createObjectURL(wmImage.files[0]);
                    img.style.width = "150px";
                    img.style.height = "auto";
                    wm.appendChild(img);
                } else {
                    wm.innerText = wmText.value;
                    wm.style.color = textColor.value;
                    wm.style.fontWeight = watermarkData.bold ? "bold" : "normal";
                    wm.style.fontStyle = watermarkData.italic ? "italic" : "normal";
                    wm.style.textDecoration = watermarkData.underline ? "underline" : "none";
                    wm.style.fontFamily = getPreviewFont(fontFamily.value);
                }

                // Temporarily add to DOM to measure (off-screen)
                wm.style.position = "absolute";
                wm.style.left = "-9999px";
                wm.style.transform = rotationTransform + " translate(-50%, -50%)";
                card.appendChild(wm);

                // Calculate position based on dropdown
                // Position watermark using FIXED CORNERS
                const canvasRect = canvas.getBoundingClientRect();
                const cardRect = card.getBoundingClientRect();

                const canvasOffsetLeft = canvasRect.left - cardRect.left;
                const canvasOffsetTop = canvasRect.top - cardRect.top;

                const padding = 10; // distance from edges

                wm.style.transform = `rotate(${rotation.value}deg)`; // no translate here

                switch (position.value) {
                    case "top-left":
                        wm.style.left = canvasOffsetLeft + padding + "px";
                        wm.style.top = canvasOffsetTop + padding + "px";
                        break;

                    case "top-right":
                        wm.style.left = canvasOffsetLeft + canvas.offsetWidth - wm.offsetWidth - padding + "px";
                        wm.style.top = canvasOffsetTop + padding + "px";
                        break;

                    case "bottom-left":
                        wm.style.left = canvasOffsetLeft + padding + "px";
                        wm.style.top = canvasOffsetTop + canvas.offsetHeight - wm.offsetHeight - padding + "px";
                        break;

                    case "bottom-right":
                        wm.style.left = canvasOffsetLeft + canvas.offsetWidth - wm.offsetWidth - padding + "px";
                        wm.style.top = canvasOffsetTop + canvas.offsetHeight - wm.offsetHeight - padding + "px";
                        break;

                    default: // center
                        wm.style.left = canvasOffsetLeft + canvas.offsetWidth / 2 + "px";
                        wm.style.top = canvasOffsetTop + canvas.offsetHeight / 2 + "px";
                        wm.style.transform = `translate(-50%, -50%) rotate(${rotation.value}deg)`;
                }

                // Add resize handles for images
                if (type === "image") {
                    const handles = ['tl', 'tr', 'bl', 'br'];
                    handles.forEach(pos => {
                        const handle = document.createElement("div");
                        handle.className = `resize-handle resize-handle-${pos}`;
                        wm.appendChild(handle);
                        makeResizable(wm, wm.querySelector("img"), handle, pos, card);
                    });
                }

                makeDraggable(wm, card);
            });
        }

        /* ===== IMPROVED DRAG WITH BETTER VERTICAL MOVEMENT ===== */
        function makeDraggable(el, card) {
            el.addEventListener("pointerdown", e => {
                if (e.target.classList.contains("resize-handle")) return;

                e.preventDefault();
                el.setPointerCapture(e.pointerId);

                const canvas = card.querySelector("canvas");

                // Get canvas position relative to card
                const canvasRect = canvas.getBoundingClientRect();
                const cardRect = card.getBoundingClientRect();
                const canvasOffsetLeft = canvasRect.left - cardRect.left;
                const canvasOffsetTop = canvasRect.top - cardRect.top;

                // Get initial position when drag starts
                const startLeft = parseFloat(el.style.left) || 0;
                const startTop = parseFloat(el.style.top) || 0;
                const startX = e.clientX;
                const startY = e.clientY;

                function move(ev) {
                    // Calculate how much the mouse has moved
                    const deltaX = ev.clientX - startX;
                    const deltaY = ev.clientY - startY;

                    // Calculate new position in card coordinates (this is the CENTER due to translate(-50%, -50%))
                    let centerX = startLeft + deltaX;
                    let centerY = startTop + deltaY;

                    // Convert center to canvas-relative coordinates
                    let canvasRelativeCenterX = centerX - canvasOffsetLeft;
                    let canvasRelativeCenterY = centerY - canvasOffsetTop;

                    el.style.left = centerX + "px";
                    el.style.top = centerY + "px";
                    if (position.value === "center") {
                        el.style.transform = `translate(-50%, -50%) rotate(${rotation.value}deg)`;
                    } else {
                        el.style.transform = `rotate(${rotation.value}deg)`;
                    }

                    // Store the CENTER position in card coordinates
                    el.dataset.actualLeft = centerX;
                    el.dataset.actualTop = centerY;

                    // Also store canvas-relative position for easier saving
                    el.dataset.canvasLeft = canvasRelativeCenterX;
                    el.dataset.canvasTop = canvasRelativeCenterY;

                    // Store watermark dimensions for backend
                    const dims = getWatermarkDimensions(el);
                    el.dataset.wmWidth = dims.width;
                    el.dataset.wmHeight = dims.height;
                    el.dataset.wmBaseWidth = dims.baseWidth;
                    el.dataset.wmBaseHeight = dims.baseHeight;

                    showApplyButton(card);
                }

                function up(ev) {
                    el.releasePointerCapture(ev.pointerId);
                    el.removeEventListener("pointermove", move);
                    el.removeEventListener("pointerup", up);
                }

                el.addEventListener("pointermove", move);
                el.addEventListener("pointerup", up);
            });
        }

        /* ===== RESIZE IMAGES WITH DIMENSION TRACKING ===== */
        function makeResizable(el, img, handle, position, card) {
            handle.addEventListener("pointerdown", e => {
                e.preventDefault();
                e.stopPropagation();

                handle.setPointerCapture(e.pointerId);

                const startWidth = img.offsetWidth;
                const startX = e.clientX;
                const aspectRatio = img.offsetHeight / startWidth;

                function move(ev) {
                    let diffX = ev.clientX - startX;
                    let diff = (position === 'br' || position === 'tr') ? diffX : -diffX;

                    const newWidth = Math.max(50, Math.min(400, startWidth + diff));
                    img.style.width = newWidth + "px";
                    img.style.height = newWidth * aspectRatio + "px";

                    // Update stored dimensions
                    const dims = getWatermarkDimensions(el);
                    el.dataset.wmWidth = dims.width;
                    el.dataset.wmHeight = dims.height;
                    el.dataset.wmBaseWidth = dims.baseWidth;
                    el.dataset.wmBaseHeight = dims.baseHeight;

                    showApplyButton(card);
                }

                function up(ev) {
                    handle.releasePointerCapture(ev.pointerId);
                    handle.removeEventListener("pointermove", move);
                    handle.removeEventListener("pointerup", up);
                }

                handle.addEventListener("pointermove", move);
                handle.addEventListener("pointerup", up);
            });
        }

        /* ===== SHOW APPLY BUTTON FOR SPECIFIC PAGE ===== */
        function showApplyButton(card) {
            const applyBtn = card.querySelector(".page-apply-btn");
            if (applyBtn) {
                applyBtn.classList.add("show");
            }
        }

        /* ===== APPLY THIS PAGE TO ALL PAGES ===== */
        function applyThisPageToAll(sourceCard) {
            const sourceWm = sourceCard.querySelector(".watermark-preview");
            if (!sourceWm) return;

            // Get actual positions from data attributes (if dragged) or from style
            const refLeft = sourceWm.dataset.actualLeft ? sourceWm.dataset.actualLeft + "px" : sourceWm.style.left;
            const refTop = sourceWm.dataset.actualTop ? sourceWm.dataset.actualTop + "px" : sourceWm.style.top;
            const refTransform = sourceWm.style.transform;

            let refWidth = null;
            let refHeight = null;
            const refImg = sourceWm.querySelector("img");
            if (refImg) {
                refWidth = refImg.style.width;
                refHeight = refImg.style.height;
            }

            // Apply to all pages in range
            document.querySelectorAll(".page-card").forEach(card => {
                if (card.classList.contains("out-of-range")) return;
                if (card === sourceCard) return; // Skip source card

                const wm = card.querySelector(".watermark-preview");
                if (wm) {
                    wm.style.left = refLeft;
                    wm.style.top = refTop;
                    wm.style.transform = refTransform;

                    // Copy all data attributes
                    if (sourceWm.dataset.actualLeft) wm.dataset.actualLeft = sourceWm.dataset.actualLeft;
                    if (sourceWm.dataset.actualTop) wm.dataset.actualTop = sourceWm.dataset.actualTop;
                    if (sourceWm.dataset.canvasLeft) wm.dataset.canvasLeft = sourceWm.dataset.canvasLeft;
                    if (sourceWm.dataset.canvasTop) wm.dataset.canvasTop = sourceWm.dataset.canvasTop;
                    if (sourceWm.dataset.wmWidth) wm.dataset.wmWidth = sourceWm.dataset.wmWidth;
                    if (sourceWm.dataset.wmHeight) wm.dataset.wmHeight = sourceWm.dataset.wmHeight;
                    if (sourceWm.dataset.wmBaseWidth) wm.dataset.wmBaseWidth = sourceWm.dataset.wmBaseWidth;
                    if (sourceWm.dataset.wmBaseHeight) wm.dataset.wmBaseHeight = sourceWm.dataset.wmBaseHeight;

                    if (refWidth) {
                        const img = wm.querySelector("img");
                        if (img) {
                            img.style.width = refWidth;
                            if (refHeight) img.style.height = refHeight;
                        }
                    }
                }

                // Hide apply button on other pages since they're now synced
                const applyBtn = card.querySelector(".page-apply-btn");
                if (applyBtn) {
                    applyBtn.classList.remove("show");
                }
            });

            // Hide the source button too
            const sourceApplyBtn = sourceCard.querySelector(".page-apply-btn");
            if (sourceApplyBtn) {
                sourceApplyBtn.classList.remove("show");
            }

            showSuccess("âœ“ Applied to all pages in range!");
        }

        /* ===== EVENT LISTENERS WITH DEBOUNCING ===== */
        // Create debounced version of updatePreview
        const debouncedUpdatePreview = debounce(updatePreview, 100);

        // Use debounced version for numeric inputs
        fontSize.addEventListener("input", debouncedUpdatePreview);
        opacity.addEventListener("input", debouncedUpdatePreview);
        rotation.addEventListener("input", debouncedUpdatePreview);

        // Keep immediate updates for these
        wmText.addEventListener("input", updatePreview);
        position.addEventListener("change", updatePreview);
        fontFamily.addEventListener("change", updatePreview);

        // Page range updates with debouncing
        pageStart.addEventListener("input", debounce(updatePageRangeDisplay, 100));
        pageEnd.addEventListener("input", debounce(updatePageRangeDisplay, 100));

        wmImage.addEventListener("change", updatePreview);

        /* ===== WATERMARK BUTTON - WITH DIMENSION DATA ===== */
        watermarkBtn.onclick = async () => {
            clearError();

            if (files.length === 0) {
                showError("Please upload at least one PDF file first!");
                return;
            }

            const type = document.querySelector("input[name='wmType']:checked").value;

            if (type === "text" && !wmText.value.trim()) {
                showError("Please enter watermark text!");
                return;
            }

            if (type === "image" && !wmImage.files[0]) {
                showError("Please select a watermark image!");
                return;
            }

            // Collect watermark positions from all pages WITH DIMENSIONS
            const pages = [];
            document.querySelectorAll(".page-card").forEach(card => {
                const wm = card.querySelector(".watermark-preview");
                if (!wm) return;

                const canvas = card.querySelector("canvas");
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;

                // Get canvas-relative CENTER position
                let canvasRelativeX, canvasRelativeY;

                if (wm.dataset.canvasLeft && wm.dataset.canvasTop) {
                    // Use stored canvas-relative position if available (from dragging)
                    canvasRelativeX = parseFloat(wm.dataset.canvasLeft);
                    canvasRelativeY = parseFloat(wm.dataset.canvasTop);
                } else {
                    // Calculate from current position
                    const canvasRect = canvas.getBoundingClientRect();
                    const cardRect = card.getBoundingClientRect();
                    const canvasOffsetLeft = canvasRect.left - cardRect.left;
                    const canvasOffsetTop = canvasRect.top - cardRect.top;

                    const cardRelativeLeft = parseFloat(wm.style.left);
                    const cardRelativeTop = parseFloat(wm.style.top);

                    canvasRelativeX = cardRelativeLeft - canvasOffsetLeft;
                    canvasRelativeY = cardRelativeTop - canvasOffsetTop;
                }

                // Convert to percentage (center position)
                const leftPercent = (canvasRelativeX / canvasWidth) * 100;
                const topPercent = (canvasRelativeY / canvasHeight) * 100;

                const pageData = {
                    pageNum: parseInt(card.dataset.pageNum),
                    left: leftPercent + "%",
                    top: topPercent + "%",
                    rotation: rotation.value,
                    // Add dimensions for backend calculations
                    wmWidth: wm.dataset.wmWidth || null,
                    wmHeight: wm.dataset.wmHeight || null,
                    wmBaseWidth: wm.dataset.wmBaseWidth || null,
                    wmBaseHeight: wm.dataset.wmBaseHeight || null
                };

                if (type === "image") {
                    const img = wm.querySelector("img");
                    if (img) {
                        const imgWidthPercent = (img.offsetWidth / canvasWidth) * 100;
                        pageData.widthPercent = imgWidthPercent;
                        pageData.width = img.offsetWidth;
                    }
                }

                pages.push(pageData);
            });

            const formData = new FormData();
            files.forEach(f => formData.append("files", f));

            formData.append("type", type);
            formData.append("text", wmText.value);
            formData.append("fontSize", fontSize.value);
            formData.append("opacity", opacity.value);
            formData.append("rotation", rotation.value);
            formData.append("fontFamily", fontFamily.value);
            formData.append("color", textColor.value);
            formData.append("bold", watermarkData.bold);
            formData.append("italic", watermarkData.italic);
            formData.append("underline", watermarkData.underline);
            formData.append("pageStart", pageStart.value);
            formData.append("pageEnd", pageEnd.value);
            formData.append("positions", JSON.stringify(pages));

            if (type === "image") {
                formData.append("image", wmImage.files[0]);
            }

            watermarkBtn.disabled = true;
            watermarkBtn.classList.add("btn-loading");
            watermarkBtn.querySelector('.btn-spinner').style.display = 'inline-block';
            watermarkBtn.querySelector('.btn-text').style.display = 'none';

            try {
                const res = await fetch(BACKEND_URL, {
                    method: "POST",
                    body: formData
                });

                if (!res.ok) throw new Error("Failed to add watermark");

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);

                // Set up download and share links
                downloadBtn.href = url;
                downloadBtn.download = "watermarked.pdf";
                shareBtn.href = url;

                // Hide upload section and show results
                uploadSection.style.display = "none";
                fileList.style.display = "none";
                pagesGrid.style.display = "none";
                wmOptions.style.display = "none";
                watermarkBtn.style.display = "none";
                errorMsg.style.display = "none";
                document.querySelector('.note-box').style.display = "none";
                resultBtns.style.display = "block";

                // Show preview on desktop, allow opening on mobile
                const isSmallDevice = window.matchMedia("(max-width: 768px)").matches;

                if (!isSmallDevice) {
                    pdfFrame.src = url;
                    pdfPreview.style.display = 'block';
                }

                fileNameLink.onclick = (e) => {
                    e.preventDefault();
                    isSmallDevice
                        ? window.open(url, "_blank")
                        : pdfPreview.scrollIntoView({ behavior: "smooth" });
                };

            } catch (error) {
                showError("Error: " + error.message);
            } finally {
                watermarkBtn.disabled = false;
                watermarkBtn.classList.remove("btn-loading");
                watermarkBtn.querySelector('.btn-spinner').style.display = 'none';
                watermarkBtn.querySelector('.btn-text').style.display = 'inline-block';
            }
        };

        /* ===== RESET BUTTON ===== */
        resetBtn.onclick = () => {
            clearError();
            successMsg.classList.remove("show");
            files = [];
            totalPagesCount = 0;
            pdfUpload.value = "";
            uploadSection.style.display = "block";
            fileList.innerHTML = "";
            fileList.style.display = "none";
            pagesGrid.innerHTML = "";
            pagesGrid.style.display = "none";
            wmOptions.style.display = "none";
            watermarkBtn.style.display = "inline-flex";
            watermarkBtn.disabled = false;
            resultBtns.style.display = "none";
            document.querySelector('.note-box').style.display = "block";

            // Reset form values
            wmText.value = "";
            fontSize.value = 36;
            opacity.value = 0.3;
            rotation.value = 0;
            position.value = "center";
            fontFamily.value = "Helvetica";
            pageStart.value = 1;
            pageEnd.value = 0;
            textColor.value = "#000000";
            textColorHex.value = "#000000";
            watermarkData = { bold: false, italic: false, underline: false };
            boldBtn.classList.remove("active");
            italicBtn.classList.remove("active");
            underlineBtn.classList.remove("active");

            // Clear the image input
            wmImage.value = "";

            // Reset to text mode
            document.querySelector("input[name='wmType'][value='text']").checked = true;
            document.getElementById("textControls").style.display = "block";
            document.getElementById("imageControls").style.display = "none";

            // Proper iframe cleanup
            pdfFrame.src = '';
            pdfPreview.style.display = 'none';
            window.scrollTo({ top: 0, behavior: "smooth" });
        };

    </script>

</body>

</html>