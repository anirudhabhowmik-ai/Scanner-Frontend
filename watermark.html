<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Add Watermark to PDF | PDFMaster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Inter:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link rel="stylesheet" href="./css/style.css" />
    <link rel="stylesheet" href="./css/watermerk.css" />
    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="./images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="./images/favicon-16x16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="./images/apple-touch-icon.png"
    />
  </head>

  <body>
    <section id="header-placeholder"></section>

    <section class="merge-tool">
      <div class="container">
        <h1>Add Watermark</h1>
        <p>
          Add watermark to multiple PDFs with custom positioning and styling.
        </p>

        <div class="upload-section">
          <div id="uploadSection">
            <label class="upload-label" for="pdfUpload"
              ><i class="fa fa-upload"></i> Choose PDF files</label
            >
            <input type="file" id="pdfUpload" accept=".pdf" multiple />
          </div>

          <div class="success-message" id="successMsg"></div>

          <ul id="fileList" class="file-list" style="display: none"></ul>
          <div id="pagesGrid" class="pages-grid" style="display: none"></div>

          <!-- OPTIONS -->
          <div id="wmOptions" style="display: none; text-align: left">
            <label>Watermark Type</label>
            <div class="radio-group">
              <label style="display: flex; align-items: center"
                ><input
                  type="radio"
                  name="wmType"
                  value="text"
                  checked
                  style="margin-top: 0"
                />
                Text</label
              >
              <label style="display: flex; align-items: center"
                ><input
                  type="radio"
                  name="wmType"
                  value="image"
                  style="margin-top: 0"
                />
                Image</label
              >
            </div>

            <div id="textControls" style="display: flex; gap: 10px">
              <div style="margin-bottom: 5px">
                <label>Watermark Text</label>
                <input
                  type="text"
                  id="wmText"
                  placeholder="Enter watermark text"
                  style="
                    padding: 6px 8px;
                    border: 1px solid #e5e7eb;
                    border-radius: 6px;
                  "
                />
              </div>

              <div>
                <label>Text Styling</label>
                <div class="text-style-buttons">
                  <!-- Font Family -->
                  <div class="option-group" id="fontFamilyGroup">
                    <select id="fontFamily">
                      <option value="Helvetica">Helvetica</option>
                      <option value="Helvetica-Bold">Helvetica Bold</option>
                      <option value="Courier">Courier</option>
                      <option value="Times-Roman">Times Roman</option>
                    </select>
                  </div>
                  <!-- Font Size -->
                  <div class="option-group" id="fontSizeGroup">
                    <input
                      type="number"
                      id="fontSize"
                      value="36"
                      min="8"
                      max="200"
                    />
                  </div>

                  <!-- Font color -->
                  <div class="color-input-wrapper">
                    <input type="color" id="textColor" value="#000000" />
                    <input
                      type="text"
                      id="textColorHex"
                      value="#000000"
                      placeholder="#000000"
                    />
                  </div>

                  <button type="button" id="boldBtn" title="Bold">
                    <i class="fa fa-bold"></i>
                  </button>
                  <button type="button" id="italicBtn" title="Italic">
                    <i class="fa fa-italic"></i>
                  </button>
                  <button type="button" id="underlineBtn" title="Underline">
                    <i class="fa fa-underline"></i>
                  </button>
                </div>
              </div>
            </div>

            <div id="imageControls" style="display: none">
              <label>Watermark Image</label>
              <input
                type="file"
                id="wmImage"
                accept="image/*"
                style="
                  padding: 10px;
                  border: 1px solid #e5e7eb;
                  border-radius: 6px;
                "
              />
            </div>

            <div class="options-grid">
              <div class="option-group">
                <label>Opacity</label>
                <input
                  type="number"
                  id="opacity"
                  step="0.1"
                  min="0.1"
                  max="1"
                  value="0.3"
                />
              </div>

              <div class="option-group">
                <label>Rotation (degrees)</label>
                <input
                  type="number"
                  id="rotation"
                  value="0"
                  min="-180"
                  max="180"
                  step="15"
                />
              </div>

              <div class="option-group">
                <label>Position</label>
                <select id="position">
                  <option value="center">Center</option>
                  <option value="top-left">Top Left</option>
                  <option value="top-right">Top Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>

              <div class="option-group">
                <label>Page Range</label>
                <div class="page-range-input">
                  <input
                    type="number"
                    id="pageStart"
                    value="1"
                    min="1"
                    placeholder="Start"
                  />
                  <input
                    type="number"
                    id="pageEnd"
                    value="0"
                    min="0"
                    placeholder="End (0=all)"
                  />
                </div>
              </div>
            </div>
          </div>

          <button id="watermarkBtn" class="cta-button" style="margin-top: 15px">
            <span class="btn-spinner">
              <i class="fa fa-spinner fa-spin"></i>
            </span>
            <span class="btn-text"><i class="fa fa-stamp"></i></span> Add
            Watermark
          </button>

          <p class="error-text" id="errorMsg"></p>
          <div class="note-box">
            ðŸ’¡ Drag watermarks to reposition and resize images. Each modified
            page will show an "Apply to All" button.
          </div>

          <div id="resultBtns" style="display: none; margin-top: 30px">
            <div class="result-card">
              <i class="fa fa-file-pdf"></i>
            </div>

            <p class="file-name">
              <a href="#" id="fileNameLink">watermarked.pdf</a>
            </p>

            <div class="result-btns-container">
              <a id="downloadBtn" href="#" class="cta-button">
                <i class="fa fa-download"></i> Download
              </a>
              <a id="shareBtn" href="#" class="cta-button">
                <i class="fa fa-share-alt"></i> Share
              </a>
              <button id="resetBtn" class="secondary-btn">
                <i class="fa fa-rotate-right"></i> Add Another Watermark
              </button>
            </div>
          </div>
        </div>

        <div id="pdfPreview" style="display: none; margin-top: 30px">
          <h4>Preview Watermarked PDF</h4>
          <iframe
            id="pdfFrame"
            width="100%"
            height="600"
            style="border-radius: 12px; border: 1px solid #e5e7eb"
          ></iframe>
        </div>
      </div>
    </section>

    <section id="footer-placeholder"></section>

    <script src="./js/app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      const BACKEND_URL = `${BACKEND_BASE_URL}/add-watermark`;
      const pdfUpload = document.getElementById("pdfUpload");
      const fileList = document.getElementById("fileList");
      const pagesGrid = document.getElementById("pagesGrid");
      const wmOptions = document.getElementById("wmOptions");
      const errorMsg = document.getElementById("errorMsg");
      const successMsg = document.getElementById("successMsg");
      const watermarkBtn = document.getElementById("watermarkBtn");
      const uploadSection = document.getElementById("uploadSection");
      const resultBtns = document.getElementById("resultBtns");
      const downloadBtn = document.getElementById("downloadBtn");
      const shareBtn = document.getElementById("shareBtn");
      const resetBtn = document.getElementById("resetBtn");
      const pdfPreview = document.getElementById("pdfPreview");
      const pdfFrame = document.getElementById("pdfFrame");
      const fileNameLink = document.getElementById("fileNameLink");

      const wmText = document.getElementById("wmText");
      const wmImage = document.getElementById("wmImage");
      const fontSize = document.getElementById("fontSize");
      const opacity = document.getElementById("opacity");
      const position = document.getElementById("position");
      const rotation = document.getElementById("rotation");
      const fontFamily = document.getElementById("fontFamily");
      const pageStart = document.getElementById("pageStart");
      const pageEnd = document.getElementById("pageEnd");
      const textColor = document.getElementById("textColor");
      const textColorHex = document.getElementById("textColorHex");

      const boldBtn = document.getElementById("boldBtn");
      const italicBtn = document.getElementById("italicBtn");
      const underlineBtn = document.getElementById("underlineBtn");

      const fontSizeGroup = document.getElementById("fontSizeGroup");
      const fontFamilyGroup = document.getElementById("fontFamilyGroup");

      let files = [];
      let watermarkData = {
        bold: false,
        italic: false,
        underline: false,
      };
      let totalPagesCount = 0;

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      function applyTransform(el, isCenter) {
        const rot = parseFloat(rotation.value) || 0;

        if (isCenter) {
          el.style.transform = `translate(-50%, -50%) rotate(${rot}deg)`;
        } else {
          el.style.transform = `rotate(${rot}deg)`;
        }
      }

      /* ===== DEBOUNCE HELPER ===== */
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      /* ===== COLOR SYNC ===== */
      textColor.oninput = () => {
        textColorHex.value = textColor.value.toUpperCase();
        updatePreview();
      };

      textColorHex.oninput = () => {
        const hex = textColorHex.value;
        if (/^#[0-9A-F]{6}$/i.test(hex)) {
          textColor.value = hex;
          updatePreview();
        }
      };

      /* ===== ERROR & SUCCESS ===== */
      function showError(msg) {
        errorMsg.textContent = msg;
        errorMsg.style.display = "block";
        successMsg.classList.remove("show");
      }

      function clearError() {
        errorMsg.textContent = "";
        errorMsg.style.display = "none";
      }

      function showSuccess(msg) {
        successMsg.textContent = msg;
        successMsg.classList.add("show");
        clearError();
        setTimeout(() => successMsg.classList.remove("show"), 3000);
      }

      /* ===== RADIO FIX - Hide font controls for images ===== */
      document.querySelectorAll("input[name='wmType']").forEach((r) => {
        r.onchange = () => {
          clearError();
          const isText = r.value === "text";
          document.getElementById("textControls").style.display = isText
            ? "flex"
            : "none";
          document.getElementById("imageControls").style.display = isText
            ? "none"
            : "block";
          updatePreview();
        };
      });

      /* ===== TEXT STYLE BUTTONS ===== */
      boldBtn.onclick = () => {
        watermarkData.bold = !watermarkData.bold;
        boldBtn.classList.toggle("active", watermarkData.bold);
        updatePreview();
      };

      italicBtn.onclick = () => {
        watermarkData.italic = !watermarkData.italic;
        italicBtn.classList.toggle("active", watermarkData.italic);
        updatePreview();
      };

      underlineBtn.onclick = () => {
        watermarkData.underline = !watermarkData.underline;
        underlineBtn.classList.toggle("active", watermarkData.underline);
        updatePreview();
      };

      /* ===== UPLOAD (NO DUPLICATES) ===== */
      pdfUpload.onchange = (e) => {
        clearError();
        const newFiles = [...e.target.files];
        newFiles.forEach((f) => {
          if (!files.some((x) => x.name === f.name && x.size === f.size))
            files.push(f);
        });
        renderFileList();
        loadAllPDFs();
      };

      /* ===== FILE LIST + DELETE FIX ===== */
      function renderFileList() {
        if (files.length === 0) {
          fileList.style.display = "none";
          pagesGrid.style.display = "none";
          wmOptions.style.display = "none";
          return;
        }
        fileList.style.display = "block";
        fileList.innerHTML = "";
        files.forEach((f, i) => {
          const li = document.createElement("li");
          li.innerHTML = `<i class="fa fa-file-pdf pdf-icon"></i> <span>${f.name}</span> <i class="fa fa-times delete-file"></i>`;
          li.querySelector(".delete-file").onclick = () => {
            files.splice(i, 1);
            renderFileList();
            loadAllPDFs();
          };
          fileList.appendChild(li);
        });
      }

      /* ===== LOAD PDF PAGES - PROPER SCALING ===== */
      async function loadAllPDFs() {
        pagesGrid.innerHTML = "";
        if (files.length === 0) return;

        pagesGrid.style.display = "flex";
        wmOptions.style.display = "block";
        totalPagesCount = 0;

        for (let file of files) {
          const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file))
            .promise;

          for (let i = 1; i <= pdf.numPages; i++) {
            totalPagesCount++;
            const page = await pdf.getPage(i);

            // Calculate DISPLAY scale to fit screen
            const maxWidth =
              window.innerWidth < 768 ? window.innerWidth - 40 : 800;
            const viewport = page.getViewport({ scale: 1 });
            const displayScale = Math.min(maxWidth / viewport.width, 1);

            // Render at HIGHER resolution for crisp text (2x or 3x)
            const renderScale = displayScale * (window.devicePixelRatio || 2);
            const scaledViewport = page.getViewport({ scale: renderScale });

            const canvas = document.createElement("canvas");
            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;

            // Render the page at high resolution
            await page.render({
              canvasContext: canvas.getContext("2d"),
              viewport: scaledViewport,
            }).promise;

            const card = document.createElement("div");
            card.className = "page-card";
            card.dataset.pageNum = totalPagesCount;

            // Store DISPLAY scale (not render scale)
            card.dataset.scale = displayScale;
            card.dataset.baseWidth = viewport.width;

            // Add page number badge
            const badge = document.createElement("div");
            badge.className = "page-number-badge";
            badge.textContent = `Page ${totalPagesCount}`;
            card.appendChild(badge);

            // Scale down canvas display with CSS for crisp rendering
            canvas.style.width = viewport.width * displayScale + "px";
            canvas.style.height = viewport.height * displayScale + "px";
            card.appendChild(canvas);

            // Add "Apply to All" button
            const applyBtn = document.createElement("button");
            applyBtn.className = "page-apply-btn";
            applyBtn.innerHTML = '<i class="fa fa-clone"></i> Apply to All';
            applyBtn.onclick = () => applyThisPageToAll(card);
            card.appendChild(applyBtn);

            pagesGrid.appendChild(card);
          }
        }

        updatePageRangeDisplay();
        updatePreview();
      }

      /* ===== UPDATE PAGE RANGE DISPLAY ===== */
      function updatePageRangeDisplay() {
        const start = parseInt(pageStart.value) || 1;
        const end = parseInt(pageEnd.value) || totalPagesCount;
        const effectiveEnd =
          end === 0 ? totalPagesCount : Math.min(end, totalPagesCount);

        document.querySelectorAll(".page-card").forEach((card) => {
          const pageNum = parseInt(card.dataset.pageNum);
          if (pageNum < start || pageNum > effectiveEnd) {
            card.classList.add("out-of-range");
          } else {
            card.classList.remove("out-of-range");
          }
        });

        updatePreview();
      }

      function getPreviewFont(pdfFont) {
        const map = {
          Helvetica: "Arial, sans-serif",
          "Helvetica-Bold": "Arial Black, Arial, sans-serif",
          Courier: "Courier New, monospace",
          "Times-Roman": "Times New Roman, serif",
        };
        return map[pdfFont] || "Arial, sans-serif";
      }

      /* ===== HELPER: GET WATERMARK DIMENSIONS (accounting for rotation) ===== */
      function getWatermarkDimensions(el) {
        const currentTransform = el.style.transform;
        el.style.transform = "translate(-50%, -50%)";

        const rect = el.getBoundingClientRect();
        const baseWidth = rect.width;
        const baseHeight = rect.height;

        el.style.transform = currentTransform;

        const rotationRad = ((parseFloat(rotation.value) || 0) * Math.PI) / 180;
        const cos = Math.abs(Math.cos(rotationRad));
        const sin = Math.abs(Math.sin(rotationRad));

        const rotatedWidth = baseWidth * cos + baseHeight * sin;
        const rotatedHeight = baseWidth * sin + baseHeight * cos;

        return {
          width: rotatedWidth,
          height: rotatedHeight,
          baseWidth: baseWidth,
          baseHeight: baseHeight,
        };
      }

      /* ===== PREVIEW - FIXED TO PRESERVE DRAGGED POSITIONS ===== */
      function updatePreview() {
        clearError();
        const type = document.querySelector(
          "input[name='wmType']:checked",
        ).value;

        document.querySelectorAll(".page-card").forEach((card) => {
          const old = card.querySelector(".watermark-preview");

          // Store current position BEFORE removing
          let storedLeft = null;
          let storedTop = null;
          let storedTransform = null;
          let storedCanvasLeft = null;
          let storedCanvasTop = null;

          if (old && (old.dataset.actualLeft || old.dataset.actualTop)) {
            storedLeft = old.dataset.actualLeft;
            storedTop = old.dataset.actualTop;
            storedTransform = old.style.transform;
            storedCanvasLeft = old.dataset.canvasLeft;
            storedCanvasTop = old.dataset.canvasTop;
          }

          if (old) old.remove();

          if (card.classList.contains("out-of-range")) return;

          const canvas = card.querySelector("canvas");
          const wm = document.createElement("div");
          wm.className = "watermark-preview";
          wm.style.opacity = opacity.value;
          const visualScale =
            canvas.offsetWidth / parseFloat(card.dataset.baseWidth);

          wm.style.fontSize = fontSize.value * visualScale + "px";

          const rotationValue = parseFloat(rotation.value) || 0;

          // Add content
          if (type === "image") {
            if (!wmImage.files[0]) return;
            wm.classList.add("has-image");
            const img = document.createElement("img");
            img.src = URL.createObjectURL(wmImage.files[0]);
            const baseImgWidth = card.dataset.imgWidth
              ? parseFloat(card.dataset.imgWidth)
              : 150;

            img.style.width = baseImgWidth * visualScale + "px";

            img.style.height = "auto";

            wm.appendChild(img);
          } else {
            wm.innerText = wmText.value;
            wm.style.color = textColor.value;
            wm.style.fontWeight = watermarkData.bold ? "bold" : "normal";
            wm.style.fontStyle = watermarkData.italic ? "italic" : "normal";
            wm.style.textDecoration = watermarkData.underline
              ? "underline"
              : "none";
            wm.style.fontFamily = getPreviewFont(fontFamily.value);
          }

          // Temporarily add off-screen to measure
          wm.style.position = "absolute";
          wm.style.left = "-9999px";
          wm.style.top = "-9999px";
          applyTransform(wm, false);
          card.appendChild(wm);

          const dims = getWatermarkDimensions(wm);
          const padding = 10;
          const canvasOffsetLeft = canvas.offsetLeft;
          const canvasOffsetTop = canvas.offsetTop;

          let left, top;

          // CRITICAL FIX: Check if position was previously stored (user dragged)
          if (storedLeft && storedTop) {
            // RESTORE the dragged position
            left = parseFloat(storedLeft);
            top = parseFloat(storedTop);
            applyTransform(wm, position.value === "center");
            wm.dataset.actualLeft = storedLeft;
            wm.dataset.actualTop = storedTop;
            if (storedCanvasLeft) wm.dataset.canvasLeft = storedCanvasLeft;
            if (storedCanvasTop) wm.dataset.canvasTop = storedCanvasTop;
          } else {
            // Use position from dropdown
            switch (position.value) {
              case "top-left":
                left = canvasOffsetLeft + padding;
                top = canvasOffsetTop + padding;
                applyTransform(wm, false);
                break;

              case "top-right":
                left =
                  canvasOffsetLeft + canvas.offsetWidth - dims.width - padding;
                top = canvasOffsetTop + padding;
                applyTransform(wm, false);
                break;

              case "bottom-left":
                left = canvasOffsetLeft + padding;
                top =
                  canvasOffsetTop + canvas.offsetHeight - dims.height - padding;
                applyTransform(wm, false);
                break;

              case "bottom-right":
                left =
                  canvasOffsetLeft + canvas.offsetWidth - dims.width - padding;
                top =
                  canvasOffsetTop + canvas.offsetHeight - dims.height - padding;
                applyTransform(wm, false);
                break;

              default: // center
                left = canvasOffsetLeft + canvas.offsetWidth / 2;
                top = canvasOffsetTop + canvas.offsetHeight / 2;
                applyTransform(wm, true);
            }
          }

          wm.style.left = left + "px";
          wm.style.top = top + "px";

          // Add resize handles for images
          if (type === "image") {
            const handles = ["tl", "tr", "bl", "br"];
            handles.forEach((pos) => {
              const handle = document.createElement("div");
              handle.className = `resize-handle resize-handle-${pos}`;
              wm.appendChild(handle);
              makeResizable(wm, wm.querySelector("img"), handle, pos, card);
            });
          }

          makeDraggable(wm, card);
        });
      }

      /* ===== IMPROVED DRAG ===== */
      function makeDraggable(el, card) {
        el.addEventListener("pointerdown", (e) => {
          if (e.target.classList.contains("resize-handle")) return;

          e.preventDefault();
          el.setPointerCapture(e.pointerId);

          const canvas = card.querySelector("canvas");
          const canvasRect = canvas.getBoundingClientRect();
          const cardRect = card.getBoundingClientRect();
          const canvasOffsetLeft = canvasRect.left - cardRect.left;
          const canvasOffsetTop = canvasRect.top - cardRect.top;

          const startLeft = parseFloat(el.style.left) || 0;
          const startTop = parseFloat(el.style.top) || 0;
          const startX = e.clientX;
          const startY = e.clientY;

          function move(ev) {
            const deltaX = ev.clientX - startX;
            const deltaY = ev.clientY - startY;

            let centerX = startLeft + deltaX;
            let centerY = startTop + deltaY;

            let canvasRelativeCenterX = centerX - canvasOffsetLeft;
            let canvasRelativeCenterY = centerY - canvasOffsetTop;

            el.style.left = centerX + "px";
            el.style.top = centerY + "px";

            applyTransform(el, position.value === "center");

            el.dataset.actualLeft = centerX;
            el.dataset.actualTop = centerY;
            el.dataset.canvasLeft = canvasRelativeCenterX;
            el.dataset.canvasTop = canvasRelativeCenterY;

            const dims = getWatermarkDimensions(el);
            el.dataset.wmWidth = dims.width;
            el.dataset.wmHeight = dims.height;
            el.dataset.wmBaseWidth = dims.baseWidth;
            el.dataset.wmBaseHeight = dims.baseHeight;

            showApplyButton(card);
          }

          function up(ev) {
            el.releasePointerCapture(ev.pointerId);
            el.removeEventListener("pointermove", move);
            el.removeEventListener("pointerup", up);
          }

          el.addEventListener("pointermove", move);
          el.addEventListener("pointerup", up);
        });
      }

      /* ===== RESIZE IMAGES ===== */
      function makeResizable(el, img, handle, position, card) {
        handle.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();

          handle.setPointerCapture(e.pointerId);

          const startWidth = img.offsetWidth;
          const startX = e.clientX;
          const aspectRatio = img.offsetHeight / startWidth;

          // Precompute visualScale once here
          const canvas = card.querySelector("canvas");
          const visualScale =
            canvas.offsetWidth / parseFloat(card.dataset.baseWidth);

          // Base width in unscaled units
          const baseWidth =
            parseFloat(card.dataset.imgWidth) || startWidth / visualScale;

          function move(ev) {
            let diffX = ev.clientX - startX;
            let diff = position === "br" || position === "tr" ? diffX : -diffX;

            // Compute new width in base units
            let newBaseWidth = baseWidth + diff / visualScale;
            newBaseWidth = Math.max(50, Math.min(400, newBaseWidth)); // clamp

            // Convert back to actual displayed width
            const newWidth = newBaseWidth * visualScale;
            img.style.width = newWidth + "px";
            img.style.height = newWidth * aspectRatio + "px";

            // Store base size for future drags/resizes
            card.dataset.imgWidth = newBaseWidth;

            const dims = getWatermarkDimensions(el);
            el.dataset.wmWidth = dims.width;
            el.dataset.wmHeight = dims.height;
            el.dataset.wmBaseWidth = dims.baseWidth;
            el.dataset.wmBaseHeight = dims.baseHeight;

            showApplyButton(card);
          }

          function up(ev) {
            handle.releasePointerCapture(ev.pointerId);
            handle.removeEventListener("pointermove", move);
            handle.removeEventListener("pointerup", up);
          }

          handle.addEventListener("pointermove", move);
          handle.addEventListener("pointerup", up);
        });
      }

      /* ===== SHOW APPLY BUTTON ===== */
      function showApplyButton(card) {
        const applyBtn = card.querySelector(".page-apply-btn");
        if (applyBtn) {
          applyBtn.classList.add("show");
        }
      }

      /* ===== APPLY TO ALL PAGES ===== */
      function applyThisPageToAll(sourceCard) {
        const sourceWm = sourceCard.querySelector(".watermark-preview");
        if (!sourceWm) return;

        const refLeft = sourceWm.dataset.actualLeft
          ? sourceWm.dataset.actualLeft + "px"
          : sourceWm.style.left;
        const refTop = sourceWm.dataset.actualTop
          ? sourceWm.dataset.actualTop + "px"
          : sourceWm.style.top;
        const refTransform = sourceWm.style.transform;

        let refWidth = null;
        let refHeight = null;
        const refImg = sourceWm.querySelector("img");
        if (refImg) {
          refWidth = refImg.style.width;
          refHeight = refImg.style.height;
        }

        document.querySelectorAll(".page-card").forEach((card) => {
          if (card.classList.contains("out-of-range")) return;
          if (card === sourceCard) return;

          const wm = card.querySelector(".watermark-preview");
          if (wm) {
            wm.style.left = refLeft;
            wm.style.top = refTop;
            wm.style.transform = refTransform;

            if (sourceWm.dataset.actualLeft)
              wm.dataset.actualLeft = sourceWm.dataset.actualLeft;
            if (sourceWm.dataset.actualTop)
              wm.dataset.actualTop = sourceWm.dataset.actualTop;
            if (sourceWm.dataset.canvasLeft)
              wm.dataset.canvasLeft = sourceWm.dataset.canvasLeft;
            if (sourceWm.dataset.canvasTop)
              wm.dataset.canvasTop = sourceWm.dataset.canvasTop;
            if (sourceWm.dataset.wmWidth)
              wm.dataset.wmWidth = sourceWm.dataset.wmWidth;
            if (sourceWm.dataset.wmHeight)
              wm.dataset.wmHeight = sourceWm.dataset.wmHeight;
            if (sourceWm.dataset.wmBaseWidth)
              wm.dataset.wmBaseWidth = sourceWm.dataset.wmBaseWidth;
            if (sourceWm.dataset.wmBaseHeight)
              wm.dataset.wmBaseHeight = sourceWm.dataset.wmBaseHeight;

            if (refWidth) {
              const img = wm.querySelector("img");
              if (img) {
                img.style.width = refWidth;
                if (refHeight) img.style.height = refHeight;
              }
            }

            if (sourceCard.dataset.imgWidth) {
              card.dataset.imgWidth = sourceCard.dataset.imgWidth; // âœ… sync size
              card.dataset.imgHeight = sourceCard.dataset.imgHeight;
            }
          }

          const applyBtn = card.querySelector(".page-apply-btn");
          if (applyBtn) {
            applyBtn.classList.remove("show");
          }
        });

        const sourceApplyBtn = sourceCard.querySelector(".page-apply-btn");
        if (sourceApplyBtn) {
          sourceApplyBtn.classList.remove("show");
        }

        showSuccess("âœ“ Applied to all pages in range!");
      }

      /* ===== EVENT LISTENERS ===== */
      const debouncedUpdatePreview = debounce(updatePreview, 100);

      fontSize.addEventListener("input", debouncedUpdatePreview);
      opacity.addEventListener("input", debouncedUpdatePreview);
      rotation.addEventListener("input", debouncedUpdatePreview);

      wmText.addEventListener("input", updatePreview);
      position.addEventListener("change", () => {
        document.querySelectorAll(".watermark-preview").forEach((wm) => {
          delete wm.dataset.actualLeft;
          delete wm.dataset.actualTop;
          delete wm.dataset.canvasLeft;
          delete wm.dataset.canvasTop;
        });
        updatePreview();
      });

      fontFamily.addEventListener("change", updatePreview);

      pageStart.addEventListener(
        "input",
        debounce(updatePageRangeDisplay, 100),
      );
      pageEnd.addEventListener("input", debounce(updatePageRangeDisplay, 100));

      wmImage.addEventListener("change", updatePreview);

      /* ===== WATERMARK BUTTON ===== */
      watermarkBtn.onclick = async () => {
        clearError();

        if (files.length === 0) {
          showError("Please upload at least one PDF file first!");
          return;
        }

        const type = document.querySelector(
          "input[name='wmType']:checked",
        ).value;

        if (type === "text" && !wmText.value.trim()) {
          showError("Please enter watermark text!");
          return;
        }

        if (type === "image" && !wmImage.files[0]) {
          showError("Please select a watermark image!");
          return;
        }

        const pages = [];
        document.querySelectorAll(".page-card").forEach((card) => {
          const wm = card.querySelector(".watermark-preview");
          if (!wm) return;

          const canvas = card.querySelector("canvas");
          const canvasWidth = canvas.offsetWidth;
          const canvasHeight = canvas.offsetHeight;

          const canvasRect = canvas.getBoundingClientRect();
          const cardRect = card.getBoundingClientRect();
          const canvasOffsetLeft = canvasRect.left - cardRect.left;
          const canvasOffsetTop = canvasRect.top - cardRect.top;

          const dims = getWatermarkDimensions(wm);
          const wmWidth = dims.width;
          const wmHeight = dims.height;

          let canvasRelativeX, canvasRelativeY;

          const isCenterTransform = wm.style.transform.includes(
            "translate(-50%, -50%)",
          );

          if (wm.dataset.actualLeft && wm.dataset.actualTop) {
            const cardRelativeLeft = parseFloat(wm.dataset.actualLeft);
            const cardRelativeTop = parseFloat(wm.dataset.actualTop);

            canvasRelativeX = cardRelativeLeft - canvasOffsetLeft;
            canvasRelativeY = cardRelativeTop - canvasOffsetTop;

            if (!isCenterTransform) {
              canvasRelativeX += wmWidth / 2;
              canvasRelativeY += wmHeight / 2;
            }
          } else {
            const cardRelativeLeft = parseFloat(wm.style.left);
            const cardRelativeTop = parseFloat(wm.style.top);

            canvasRelativeX = cardRelativeLeft - canvasOffsetLeft;
            canvasRelativeY = cardRelativeTop - canvasOffsetTop;

            if (!isCenterTransform) {
              canvasRelativeX += wmWidth / 2;
              canvasRelativeY += wmHeight / 2;
            }
          }

          const leftPercent = (canvasRelativeX / canvasWidth) * 100;
          const topPercent = (canvasRelativeY / canvasHeight) * 100;

          let alignment = "center";
          switch (position.value) {
            case "top-left":
            case "bottom-left":
              alignment = "left";
              break;
            case "top-right":
            case "bottom-right":
              alignment = "right";
              break;
            default:
              alignment = "center";
          }

          const pageData = {
            pageNum: parseInt(card.dataset.pageNum),
            left: leftPercent + "%",
            top: topPercent + "%",
            rotation: -parseFloat(rotation.value),
            position: alignment,
          };

          if (type === "image") {
            const img = wm.querySelector("img");
            if (img) {
              const imgWidthPercent = (img.offsetWidth / canvasWidth) * 100;
              pageData.widthPercent = imgWidthPercent;
            }
          }

          pages.push(pageData);
        });

        const formData = new FormData();
        files.forEach((f) => formData.append("files", f));

        formData.append("type", type);
        formData.append("text", wmText.value);
        formData.append("fontSize", fontSize.value);
        formData.append("opacity", opacity.value);
        formData.append("rotation", rotation.value);
        formData.append("fontFamily", fontFamily.value);
        formData.append("color", textColor.value);
        formData.append("bold", watermarkData.bold);
        formData.append("italic", watermarkData.italic);
        formData.append("underline", watermarkData.underline);
        formData.append("pageStart", pageStart.value);
        formData.append("pageEnd", pageEnd.value);
        formData.append("positions", JSON.stringify(pages));

        if (type === "image") {
          formData.append("image", wmImage.files[0]);
        }

        watermarkBtn.disabled = true;
        watermarkBtn.classList.add("btn-loading");
        watermarkBtn.querySelector(".btn-spinner").style.display =
          "inline-block";
        watermarkBtn.querySelector(".btn-text").style.display = "none";

        try {
          const res = await fetch(BACKEND_URL, {
            method: "POST",
            body: formData,
          });

          if (!res.ok) throw new Error("Failed to add watermark");

          const blob = await res.blob();
          const url = URL.createObjectURL(blob);

          downloadBtn.href = url;
          downloadBtn.download = "watermarked.pdf";
          shareBtn.href = url;

          uploadSection.style.display = "none";
          fileList.style.display = "none";
          pagesGrid.style.display = "none";
          wmOptions.style.display = "none";
          watermarkBtn.style.display = "none";
          errorMsg.style.display = "none";
          document.querySelector(".note-box").style.display = "none";
          resultBtns.style.display = "block";

          const isSmallDevice = window.matchMedia("(max-width: 768px)").matches;

          if (!isSmallDevice) {
            pdfFrame.src = url;
            pdfPreview.style.display = "block";
          }

          fileNameLink.onclick = (e) => {
            e.preventDefault();
            isSmallDevice
              ? window.open(url, "_blank")
              : pdfPreview.scrollIntoView({ behavior: "smooth" });
          };
        } catch (error) {
          showError("Error: " + error.message);
        } finally {
          watermarkBtn.disabled = false;
          watermarkBtn.classList.remove("btn-loading");
          watermarkBtn.querySelector(".btn-spinner").style.display = "none";
          watermarkBtn.querySelector(".btn-text").style.display =
            "inline-block";
        }
      };

      /* ===== RESET BUTTON ===== */
      resetBtn.onclick = () => {
        clearError();
        successMsg.classList.remove("show");
        files = [];
        totalPagesCount = 0;
        pdfUpload.value = "";
        uploadSection.style.display = "block";
        fileList.innerHTML = "";
        fileList.style.display = "none";
        pagesGrid.innerHTML = "";
        pagesGrid.style.display = "none";
        wmOptions.style.display = "none";
        watermarkBtn.style.display = "inline-flex";
        watermarkBtn.disabled = false;
        resultBtns.style.display = "none";
        document.querySelector(".note-box").style.display = "block";

        wmText.value = "";
        fontSize.value = 36;
        opacity.value = 0.3;
        rotation.value = 0;
        position.value = "center";
        fontFamily.value = "Helvetica";
        pageStart.value = 1;
        pageEnd.value = 0;
        textColor.value = "#000000";
        textColorHex.value = "#000000";
        watermarkData = { bold: false, italic: false, underline: false };
        boldBtn.classList.remove("active");
        italicBtn.classList.remove("active");
        underlineBtn.classList.remove("active");

        wmImage.value = "";

        document.querySelector("input[name='wmType'][value='text']").checked =
          true;
        document.getElementById("textControls").style.display = "flex";
        document.getElementById("imageControls").style.display = "none";

        pdfFrame.src = "";
        pdfPreview.style.display = "none";
        window.scrollTo({ top: 0, behavior: "smooth" });
      };
    </script>
  </body>
</html>
